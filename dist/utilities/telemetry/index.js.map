{"version":3,"sources":["../../../src/utilities/telemetry/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport { execSync } from 'child_process'\nimport ciInfo from 'ci-info'\nimport { randomBytes } from 'crypto'\nimport fs from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\n\nimport type { Payload } from '../../types/index.js'\nimport type { AdminInitEvent } from './events/adminInit.js'\nimport type { ServerInitEvent } from './events/serverInit.js'\n\nimport { findUp } from '../findUp.js'\nimport { Conf } from './conf/index.js'\nimport { oneWayHash } from './oneWayHash.js'\n\nexport type BaseEvent = {\n  ciName: null | string\n  dbAdapter: string\n  emailAdapter: null | string\n  envID: string\n  isCI: boolean\n  locales: string[]\n  localizationDefaultLocale: null | string\n  localizationEnabled: boolean\n  nodeEnv: string\n  nodeVersion: string\n  payloadVersion: string\n  projectID: string\n  projectIDSource: 'cwd' | 'git' | 'packageJSON' | 'serverURL'\n  uploadAdapters: string[]\n}\n\ntype PackageJSON = {\n  dependencies: Record<string, string | undefined>\n  name: string\n}\n\ntype TelemetryEvent = AdminInitEvent | ServerInitEvent\n\ntype Args = {\n  event: TelemetryEvent\n  payload: Payload\n}\n\nlet baseEvent: BaseEvent | null = null\n\nexport const sendEvent = async ({ event, payload }: Args): Promise<void> => {\n  try {\n    const { packageJSON, packageJSONPath } = await getPackageJSON()\n\n    // Only generate the base event once\n    if (!baseEvent) {\n      const { projectID, source: projectIDSource } = getProjectID(payload, packageJSON)\n      baseEvent = {\n        ciName: ciInfo.isCI ? ciInfo.name : null,\n        envID: getEnvID(),\n        isCI: ciInfo.isCI,\n        nodeEnv: process.env.NODE_ENV || 'development',\n        nodeVersion: process.version,\n        payloadVersion: getPayloadVersion(packageJSON),\n        projectID,\n        projectIDSource,\n        ...getLocalizationInfo(payload),\n        dbAdapter: payload.db.name,\n        emailAdapter: payload.email?.name || null,\n        uploadAdapters: payload.config.upload.adapters,\n      }\n    }\n\n    if (process.env.PAYLOAD_TELEMETRY_DEBUG) {\n      payload.logger.info({\n        event: { ...baseEvent, ...event, packageJSONPath },\n        msg: 'Telemetry Event',\n      })\n      return\n    }\n\n    if (payload.config.telemetry !== false) {\n      await fetch('https://telemetry.payloadcms.com/events', {\n        body: JSON.stringify({ ...baseEvent, ...event }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        method: 'post',\n      })\n    }\n  } catch (_) {\n    // Eat any errors in sending telemetry event\n  }\n}\n\n/**\n * This is a quasi-persistent identifier used to dedupe recurring events. It's\n * generated from random data and completely anonymous.\n */\nconst getEnvID = (): string => {\n  const conf = new Conf()\n  const ENV_ID = 'envID'\n\n  const val = conf.get(ENV_ID)\n  if (val) {\n    return val as string\n  }\n\n  const generated = randomBytes(32).toString('hex')\n  conf.set(ENV_ID, generated)\n  return generated\n}\n\nconst getProjectID = (\n  payload: Payload,\n  packageJSON: PackageJSON,\n): { projectID: string; source: BaseEvent['projectIDSource'] } => {\n  const gitID = getGitID(payload)\n  if (gitID) {\n    return { projectID: oneWayHash(gitID, payload.secret), source: 'git' }\n  }\n\n  const packageJSONID = getPackageJSONID(payload, packageJSON)\n  if (packageJSONID) {\n    return { projectID: oneWayHash(packageJSONID, payload.secret), source: 'packageJSON' }\n  }\n\n  const serverURL = payload.config.serverURL\n  if (serverURL) {\n    return { projectID: oneWayHash(serverURL, payload.secret), source: 'serverURL' }\n  }\n\n  const cwd = process.cwd()\n  return { projectID: oneWayHash(cwd, payload.secret), source: 'cwd' }\n}\n\nconst getGitID = (payload: Payload) => {\n  try {\n    const originBuffer = execSync('git config --local --get remote.origin.url', {\n      stdio: 'pipe',\n      timeout: 1000,\n    })\n\n    return oneWayHash(String(originBuffer).trim(), payload.secret)\n  } catch (_) {\n    return null\n  }\n}\n\nconst getPackageJSON = async (): Promise<{\n  packageJSON?: PackageJSON\n  packageJSONPath: string\n}> => {\n  let packageJSONPath = path.resolve(process.cwd(), 'package.json')\n\n  if (!fs.existsSync(packageJSONPath)) {\n    // Old logic\n    const filename = fileURLToPath(import.meta.url)\n    const dirname = path.dirname(filename)\n    packageJSONPath = await findUp({\n      dir: dirname,\n      fileNames: ['package.json'],\n    })\n  }\n\n  const jsonContentString = await fs.promises.readFile(packageJSONPath, 'utf-8')\n  const jsonContent: PackageJSON = JSON.parse(jsonContentString)\n  return { packageJSON: jsonContent, packageJSONPath }\n}\n\nconst getPackageJSONID = (payload: Payload, packageJSON: PackageJSON): string => {\n  return oneWayHash(packageJSON.name, payload.secret)\n}\n\nexport const getPayloadVersion = (packageJSON: PackageJSON): string => {\n  return packageJSON?.dependencies?.payload ?? ''\n}\n\nexport const getLocalizationInfo = (\n  payload: Payload,\n): Pick<BaseEvent, 'locales' | 'localizationDefaultLocale' | 'localizationEnabled'> => {\n  if (!payload.config.localization) {\n    return {\n      locales: [],\n      localizationDefaultLocale: null,\n      localizationEnabled: false,\n    }\n  }\n\n  return {\n    locales: payload.config.localization.localeCodes,\n    localizationDefaultLocale: payload.config.localization.defaultLocale,\n    localizationEnabled: true,\n  }\n}\n"],"names":["execSync","ciInfo","randomBytes","fs","path","fileURLToPath","findUp","Conf","oneWayHash","baseEvent","sendEvent","event","payload","packageJSON","packageJSONPath","getPackageJSON","projectID","source","projectIDSource","getProjectID","ciName","isCI","name","envID","getEnvID","nodeEnv","process","env","NODE_ENV","nodeVersion","version","payloadVersion","getPayloadVersion","getLocalizationInfo","dbAdapter","db","emailAdapter","email","uploadAdapters","config","upload","adapters","PAYLOAD_TELEMETRY_DEBUG","logger","info","msg","telemetry","fetch","body","JSON","stringify","headers","method","_","conf","ENV_ID","val","get","generated","toString","set","gitID","getGitID","secret","packageJSONID","getPackageJSONID","serverURL","cwd","originBuffer","stdio","timeout","String","trim","resolve","existsSync","filename","url","dirname","dir","fileNames","jsonContentString","promises","readFile","jsonContent","parse","dependencies","localization","locales","localizationDefaultLocale","localizationEnabled","localeCodes","defaultLocale"],"mappings":"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"}