{"version":3,"sources":["../../src/utilities/routeError.ts"],"sourcesContent":["import { status as httpStatus } from 'http-status'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { ErrorResult, SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { getPayload } from '../index.js'\nimport { formatErrors } from './formatErrors.js'\nimport { headersWithCors } from './headersWithCors.js'\nimport { logError } from './logError.js'\nimport { mergeHeaders } from './mergeHeaders.js'\n\nexport const routeError = async ({\n  collection,\n  config: configArg,\n  err,\n  req: incomingReq,\n}: {\n  collection?: Collection\n  config: Promise<SanitizedConfig> | SanitizedConfig\n  err: APIError\n  req: PayloadRequest | Request\n}) => {\n  if ('payloadInitError' in err && err.payloadInitError === true) {\n    // do not attempt initializing Payload if the error is due to a failed initialization. Otherwise,\n    // it will cause an infinite loop of initialization attempts and endless error responses, without\n    // actually logging the error, as the error logging code will never be reached.\n    console.error(err)\n    return Response.json(\n      {\n        message: 'There was an error initializing Payload',\n      },\n      { status: httpStatus.INTERNAL_SERVER_ERROR },\n    )\n  }\n\n  let payload = incomingReq && 'payload' in incomingReq && incomingReq?.payload\n\n  if (!payload) {\n    try {\n      payload = await getPayload({ config: configArg })\n    } catch (e) {\n      return Response.json(\n        {\n          message: 'There was an error initializing Payload',\n        },\n        { status: httpStatus.INTERNAL_SERVER_ERROR },\n      )\n    }\n  }\n\n  let response = formatErrors(err)\n\n  let status = err.status || httpStatus.INTERNAL_SERVER_ERROR\n\n  logError({ err, payload })\n\n  const req = incomingReq as PayloadRequest\n\n  req.payload = payload\n  const headers = headersWithCors({\n    headers: new Headers(),\n    req,\n  })\n\n  const { config } = payload\n\n  // Internal server errors can contain anything, including potentially sensitive data.\n  // Therefore, error details will be hidden from the response unless `config.debug` is `true`\n  if (!config.debug && !err.isPublic && status === httpStatus.INTERNAL_SERVER_ERROR) {\n    response = formatErrors(new APIError('Something went wrong.'))\n  }\n\n  if (config.debug && config.debug === true) {\n    response.stack = err.stack\n  }\n\n  if (collection) {\n    await collection.config.hooks.afterError?.reduce(async (promise, hook) => {\n      await promise\n\n      const result = await hook({\n        collection: collection.config,\n        context: req.context,\n        error: err,\n        req,\n        result: response,\n      })\n\n      if (result) {\n        response = (result.response as ErrorResult) || response\n        status = result.status || status\n      }\n    }, Promise.resolve())\n  }\n\n  await config.hooks.afterError?.reduce(async (promise, hook) => {\n    await promise\n\n    const result = await hook({\n      collection: collection?.config,\n      context: req.context,\n      error: err,\n      req,\n      result: response,\n    })\n\n    if (result) {\n      response = (result.response as ErrorResult) || response\n      status = result.status || status\n    }\n  }, Promise.resolve())\n\n  return Response.json(response, {\n    headers: req.responseHeaders ? mergeHeaders(req.responseHeaders, headers) : headers,\n    status,\n  })\n}\n"],"names":["status","httpStatus","APIError","getPayload","formatErrors","headersWithCors","logError","mergeHeaders","routeError","collection","config","configArg","err","req","incomingReq","payloadInitError","console","error","Response","json","message","INTERNAL_SERVER_ERROR","payload","e","response","headers","Headers","debug","isPublic","stack","hooks","afterError","reduce","promise","hook","result","context","Promise","resolve","responseHeaders"],"mappings":"AAAA,SAASA,UAAUC,UAAU,QAAQ,cAAa;AAMlD,SAASC,QAAQ,QAAQ,wBAAuB;AAChD,SAASC,UAAU,QAAQ,cAAa;AACxC,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,QAAQ,QAAQ,gBAAe;AACxC,SAASC,YAAY,QAAQ,oBAAmB;AAEhD,OAAO,MAAMC,aAAa,OAAO,EAC/BC,UAAU,EACVC,QAAQC,SAAS,EACjBC,GAAG,EACHC,KAAKC,WAAW,EAMjB;IACC,IAAI,sBAAsBF,OAAOA,IAAIG,gBAAgB,KAAK,MAAM;QAC9D,iGAAiG;QACjG,iGAAiG;QACjG,+EAA+E;QAC/EC,QAAQC,KAAK,CAACL;QACd,OAAOM,SAASC,IAAI,CAClB;YACEC,SAAS;QACX,GACA;YAAEpB,QAAQC,WAAWoB,qBAAqB;QAAC;IAE/C;IAEA,IAAIC,UAAUR,eAAe,aAAaA,eAAeA,aAAaQ;IAEtE,IAAI,CAACA,SAAS;QACZ,IAAI;YACFA,UAAU,MAAMnB,WAAW;gBAAEO,QAAQC;YAAU;QACjD,EAAE,OAAOY,GAAG;YACV,OAAOL,SAASC,IAAI,CAClB;gBACEC,SAAS;YACX,GACA;gBAAEpB,QAAQC,WAAWoB,qBAAqB;YAAC;QAE/C;IACF;IAEA,IAAIG,WAAWpB,aAAaQ;IAE5B,IAAIZ,SAASY,IAAIZ,MAAM,IAAIC,WAAWoB,qBAAqB;IAE3Df,SAAS;QAAEM;QAAKU;IAAQ;IAExB,MAAMT,MAAMC;IAEZD,IAAIS,OAAO,GAAGA;IACd,MAAMG,UAAUpB,gBAAgB;QAC9BoB,SAAS,IAAIC;QACbb;IACF;IAEA,MAAM,EAAEH,MAAM,EAAE,GAAGY;IAEnB,qFAAqF;IACrF,4FAA4F;IAC5F,IAAI,CAACZ,OAAOiB,KAAK,IAAI,CAACf,IAAIgB,QAAQ,IAAI5B,WAAWC,WAAWoB,qBAAqB,EAAE;QACjFG,WAAWpB,aAAa,IAAIF,SAAS;IACvC;IAEA,IAAIQ,OAAOiB,KAAK,IAAIjB,OAAOiB,KAAK,KAAK,MAAM;QACzCH,SAASK,KAAK,GAAGjB,IAAIiB,KAAK;IAC5B;IAEA,IAAIpB,YAAY;QACd,MAAMA,WAAWC,MAAM,CAACoB,KAAK,CAACC,UAAU,EAAEC,OAAO,OAAOC,SAASC;YAC/D,MAAMD;YAEN,MAAME,SAAS,MAAMD,KAAK;gBACxBzB,YAAYA,WAAWC,MAAM;gBAC7B0B,SAASvB,IAAIuB,OAAO;gBACpBnB,OAAOL;gBACPC;gBACAsB,QAAQX;YACV;YAEA,IAAIW,QAAQ;gBACVX,WAAW,AAACW,OAAOX,QAAQ,IAAoBA;gBAC/CxB,SAASmC,OAAOnC,MAAM,IAAIA;YAC5B;QACF,GAAGqC,QAAQC,OAAO;IACpB;IAEA,MAAM5B,OAAOoB,KAAK,CAACC,UAAU,EAAEC,OAAO,OAAOC,SAASC;QACpD,MAAMD;QAEN,MAAME,SAAS,MAAMD,KAAK;YACxBzB,YAAYA,YAAYC;YACxB0B,SAASvB,IAAIuB,OAAO;YACpBnB,OAAOL;YACPC;YACAsB,QAAQX;QACV;QAEA,IAAIW,QAAQ;YACVX,WAAW,AAACW,OAAOX,QAAQ,IAAoBA;YAC/CxB,SAASmC,OAAOnC,MAAM,IAAIA;QAC5B;IACF,GAAGqC,QAAQC,OAAO;IAElB,OAAOpB,SAASC,IAAI,CAACK,UAAU;QAC7BC,SAASZ,IAAI0B,eAAe,GAAGhC,aAAaM,IAAI0B,eAAe,EAAEd,WAAWA;QAC5EzB;IACF;AACF,EAAC"}