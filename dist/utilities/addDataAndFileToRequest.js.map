{"version":3,"sources":["../../src/utilities/addDataAndFileToRequest.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { PayloadRequest } from '../types/index.js'\n\nimport { APIError } from '../errors/APIError.js'\nimport { fetchAPIFileUpload } from '../uploads/fetchAPI-multipart/index.js'\n\ntype AddDataAndFileToRequest = (req: PayloadRequest) => Promise<void>\n\n/**\n * Mutates the Request, appending 'data' and 'file' if found\n */\nexport const addDataAndFileToRequest: AddDataAndFileToRequest = async (req) => {\n  const { body, headers, method, payload } = req\n\n  if (method && ['PATCH', 'POST', 'PUT'].includes(method.toUpperCase()) && body) {\n    const [contentType] = (headers.get('Content-Type') || '').split(';')\n    const bodyByteSize = parseInt(req.headers.get('Content-Length') || '0', 10)\n\n    if (contentType === 'application/json') {\n      let data = {}\n      try {\n        const text = await req.text()\n        data = text ? JSON.parse(text) : {}\n      } catch (error) {\n        req.payload.logger.error(error)\n      } finally {\n        req.data = data\n        req.json = () => Promise.resolve(data)\n      }\n    } else if (bodyByteSize && contentType.includes('multipart/')) {\n      const { error, fields, files } = await fetchAPIFileUpload({\n        options: payload.config.upload,\n        request: req as Request,\n      })\n\n      if (error) {\n        throw new APIError(error.message)\n      }\n\n      if (files?.file) {\n        req.file = files.file\n      }\n\n      if (fields?._payload && typeof fields._payload === 'string') {\n        req.data = JSON.parse(fields._payload)\n      }\n\n      if (!req.file && fields?.file && typeof fields?.file === 'string') {\n        const { clientUploadContext, collectionSlug, filename, mimeType, size } = JSON.parse(\n          fields.file,\n        )\n        const uploadConfig = req.payload.collections[collectionSlug].config.upload\n\n        if (!uploadConfig.handlers) {\n          throw new APIError('uploadConfig.handlers is not present for ' + collectionSlug)\n        }\n\n        let response: null | Response = null\n        let error: unknown\n\n        for (const handler of uploadConfig.handlers) {\n          try {\n            const result = await handler(req, {\n              doc: null,\n              params: {\n                clientUploadContext, // Pass additional specific to adapters context returned from UploadHandler, then staticHandler can use them.\n                collection: collectionSlug,\n                filename,\n              },\n            })\n            if (result) {\n              response = result\n            }\n            // If we couldn't get the file from that handler, save the error and try other.\n          } catch (err) {\n            error = err\n          }\n        }\n\n        if (!response) {\n          if (error) {\n            payload.logger.error(error)\n          }\n\n          throw new APIError('Expected response from the upload handler.')\n        }\n\n        req.file = {\n          name: filename,\n          clientUploadContext,\n          data: Buffer.from(await response.arrayBuffer()),\n          mimetype: response.headers.get('Content-Type') || mimeType,\n          size,\n        }\n      }\n    }\n  }\n}\n"],"names":["APIError","fetchAPIFileUpload","addDataAndFileToRequest","req","body","headers","method","payload","includes","toUpperCase","contentType","get","split","bodyByteSize","parseInt","data","text","JSON","parse","error","logger","json","Promise","resolve","fields","files","options","config","upload","request","message","file","_payload","clientUploadContext","collectionSlug","filename","mimeType","size","uploadConfig","collections","handlers","response","handler","result","doc","params","collection","err","name","Buffer","from","arrayBuffer","mimetype"],"mappings":"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"}