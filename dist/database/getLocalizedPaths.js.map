{"version":3,"sources":["../../src/database/getLocalizedPaths.ts"],"sourcesContent":["import type { PathToQuery } from './queryValidation/types.js'\n\nimport { APIError, type Payload, type SanitizedCollectionConfig } from '../index.js'\n\n// @ts-strict-ignore\nimport {\n  type Field,\n  fieldShouldBeLocalized,\n  type FlattenedBlock,\n  type FlattenedField,\n} from '../fields/config/types.js'\n\nexport function getLocalizedPaths({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  overrideAccess = false,\n  parentIsLocalized,\n  payload,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  overrideAccess?: boolean\n  /**\n   * @todo make required in v4.0. Usually, you'd wanna pass this through\n   */\n  parentIsLocalized?: boolean\n  payload: Payload\n}): PathToQuery[] {\n  const pathSegments = incomingPath.split('.')\n  const localizationConfig = payload.config.localization\n\n  let paths: PathToQuery[] = [\n    {\n      collectionSlug,\n      complete: false,\n      field: undefined,\n      fields,\n      globalSlug,\n      invalid: false,\n      parentIsLocalized,\n      path: '',\n    },\n  ]\n\n  for (let i = 0; i < pathSegments.length; i += 1) {\n    const segment = pathSegments[i]\n\n    const lastIncompletePath = paths.find(({ complete }) => !complete)\n\n    if (lastIncompletePath) {\n      const { path } = lastIncompletePath\n      let currentPath = path ? `${path}.${segment}` : segment\n\n      let fieldsToSearch: FlattenedField[]\n      let _parentIsLocalized = parentIsLocalized\n\n      let matchedField: FlattenedField\n\n      if (lastIncompletePath?.field?.type === 'blocks') {\n        if (segment === 'blockType') {\n          matchedField = {\n            name: 'blockType',\n            type: 'text',\n          }\n        } else {\n          for (const _block of lastIncompletePath.field.blockReferences ??\n            lastIncompletePath.field.blocks) {\n            let block: FlattenedBlock\n            if (typeof _block === 'string') {\n              block = payload?.blocks[_block]\n            } else {\n              block = _block\n            }\n\n            matchedField = block.flattenedFields.find((field) => field.name === segment)\n            if (matchedField) {\n              break\n            }\n          }\n        }\n      } else {\n        if (lastIncompletePath?.field && 'flattenedFields' in lastIncompletePath.field) {\n          fieldsToSearch = lastIncompletePath.field.flattenedFields\n        } else {\n          fieldsToSearch = lastIncompletePath.fields\n        }\n        _parentIsLocalized = parentIsLocalized || lastIncompletePath.field?.localized\n\n        matchedField = fieldsToSearch.find((field) => field.name === segment)\n      }\n\n      lastIncompletePath.field = matchedField\n\n      if (currentPath === 'globalType' && globalSlug) {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'globalType',\n          type: 'text',\n        }\n\n        return paths\n      }\n\n      if (currentPath === 'relationTo') {\n        lastIncompletePath.path = currentPath\n        lastIncompletePath.complete = true\n        lastIncompletePath.field = {\n          name: 'relationTo',\n          type: 'select',\n          options: Object.keys(payload.collections),\n        }\n\n        return paths\n      }\n\n      if (!matchedField && currentPath === 'id' && i === pathSegments.length - 1) {\n        lastIncompletePath.path = currentPath\n        const idField: Field = {\n          name: 'id',\n          type: payload.db.defaultIDType as 'text',\n        }\n        lastIncompletePath.field = idField\n        lastIncompletePath.complete = true\n        return paths\n      }\n\n      if (matchedField) {\n        if ('hidden' in matchedField && matchedField.hidden && !overrideAccess) {\n          lastIncompletePath.invalid = true\n        }\n\n        const nextSegment = pathSegments[i + 1]\n        const nextSegmentIsLocale =\n          localizationConfig && localizationConfig.localeCodes.includes(nextSegment)\n\n        if (nextSegmentIsLocale) {\n          // Skip the next iteration, because it's a locale\n          i += 1\n          currentPath = `${currentPath}.${nextSegment}`\n        } else if (\n          localizationConfig &&\n          fieldShouldBeLocalized({ field: matchedField, parentIsLocalized: _parentIsLocalized })\n        ) {\n          currentPath = `${currentPath}.${locale}`\n        }\n\n        switch (matchedField.type) {\n          case 'join':\n          case 'relationship':\n          case 'upload': {\n            // If this is a polymorphic relation,\n            // We only support querying directly (no nested querying)\n            if (matchedField.type !== 'join' && typeof matchedField.relationTo !== 'string') {\n              const lastSegmentIsValid =\n                ['relationTo', 'value'].includes(pathSegments[pathSegments.length - 1]) ||\n                pathSegments.length === 1 ||\n                (pathSegments.length === 2 && pathSegments[0] === 'version')\n\n              lastIncompletePath.path = pathSegments.join('.')\n\n              if (lastSegmentIsValid) {\n                lastIncompletePath.complete = true\n              } else {\n                lastIncompletePath.invalid = true\n                return paths\n              }\n            } else {\n              lastIncompletePath.complete = true\n              lastIncompletePath.path = currentPath\n\n              const nestedPathToQuery = pathSegments\n                .slice(nextSegmentIsLocale ? i + 2 : i + 1)\n                .join('.')\n\n              if (nestedPathToQuery) {\n                let relatedCollection: SanitizedCollectionConfig\n                if (matchedField.type === 'join') {\n                  if (Array.isArray(matchedField.collection)) {\n                    throw new APIError('Not supported')\n                  }\n\n                  relatedCollection = payload.collections[matchedField.collection].config\n                } else {\n                  relatedCollection = payload.collections[matchedField.relationTo as string].config\n                }\n\n                const remainingPaths = getLocalizedPaths({\n                  collectionSlug: relatedCollection.slug,\n                  fields: relatedCollection.flattenedFields,\n                  globalSlug,\n                  incomingPath: nestedPathToQuery,\n                  locale,\n                  parentIsLocalized: false,\n                  payload,\n                })\n\n                paths = [...paths, ...remainingPaths]\n              }\n\n              return paths\n            }\n\n            break\n          }\n          case 'json':\n          case 'richText': {\n            const upcomingSegments = pathSegments.slice(i + 1).join('.')\n            lastIncompletePath.complete = true\n            lastIncompletePath.path = upcomingSegments\n              ? `${currentPath}.${upcomingSegments}`\n              : currentPath\n            return paths\n          }\n\n          default: {\n            if (i + 1 === pathSegments.length) {\n              lastIncompletePath.complete = true\n            }\n            lastIncompletePath.path = currentPath\n          }\n        }\n      } else {\n        lastIncompletePath.invalid = true\n        lastIncompletePath.path = currentPath\n        return paths\n      }\n    }\n  }\n\n  return paths\n}\n"],"names":["APIError","fieldShouldBeLocalized","getLocalizedPaths","collectionSlug","fields","globalSlug","incomingPath","locale","overrideAccess","parentIsLocalized","payload","pathSegments","split","localizationConfig","config","localization","paths","complete","field","undefined","invalid","path","i","length","segment","lastIncompletePath","find","currentPath","fieldsToSearch","_parentIsLocalized","matchedField","type","name","_block","blockReferences","blocks","block","flattenedFields","localized","options","Object","keys","collections","idField","db","defaultIDType","hidden","nextSegment","nextSegmentIsLocale","localeCodes","includes","relationTo","lastSegmentIsValid","join","nestedPathToQuery","slice","relatedCollection","Array","isArray","collection","remainingPaths","slug","upcomingSegments"],"mappings":"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"}