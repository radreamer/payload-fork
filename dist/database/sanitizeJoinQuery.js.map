{"version":3,"sources":["../../src/database/sanitizeJoinQuery.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { SanitizedCollectionConfig, SanitizedJoin } from '../collections/config/types.js'\nimport type { FlattenedField } from '../fields/config/types.js'\nimport type { JoinQuery, PayloadRequest } from '../types/index.js'\n\nimport executeAccess from '../auth/executeAccess.js'\nimport { QueryError } from '../errors/QueryError.js'\nimport { combineQueries } from './combineQueries.js'\nimport { validateQueryPaths } from './queryValidation/validateQueryPaths.js'\n\ntype Args = {\n  collectionConfig: SanitizedCollectionConfig\n  joins?: JoinQuery\n  overrideAccess: boolean\n  req: PayloadRequest\n}\n\nconst sanitizeJoinFieldQuery = async ({\n  collectionSlug,\n  errors,\n  join,\n  joinsQuery,\n  overrideAccess,\n  promises,\n  req,\n}: {\n  collectionSlug: string\n  errors: { path: string }[]\n  join: SanitizedJoin\n  joinsQuery: JoinQuery\n  overrideAccess: boolean\n  promises: Promise<void>[]\n  req: PayloadRequest\n}) => {\n  const { joinPath } = join\n\n  if (joinsQuery[joinPath] === false) {\n    return\n  }\n\n  const joinCollectionConfig = req.payload.collections[collectionSlug].config\n\n  const accessResult = !overrideAccess\n    ? await executeAccess({ disableErrors: true, req }, joinCollectionConfig.access.read)\n    : true\n\n  if (accessResult === false) {\n    joinsQuery[joinPath] = false\n    return\n  }\n\n  if (!joinsQuery[joinPath]) {\n    joinsQuery[joinPath] = {}\n  }\n\n  const joinQuery = joinsQuery[joinPath]\n\n  if (!joinQuery.where) {\n    joinQuery.where = {}\n  }\n\n  if (join.field.where) {\n    joinQuery.where = combineQueries(joinQuery.where, join.field.where)\n  }\n\n  promises.push(\n    validateQueryPaths({\n      collectionConfig: joinCollectionConfig,\n      errors,\n      overrideAccess,\n      polymorphicJoin: Array.isArray(join.field.collection),\n      req,\n      // incoming where input, but we shouldn't validate generated from the access control.\n      where: joinQuery.where,\n    }),\n  )\n\n  if (typeof accessResult === 'object') {\n    joinQuery.where = combineQueries(joinQuery.where, accessResult)\n  }\n}\n\n/**\n * * Validates `where` for each join\n * * Combines the access result for joined collection\n * * Combines the default join's `where`\n */\nexport const sanitizeJoinQuery = async ({\n  collectionConfig,\n  joins: joinsQuery,\n  overrideAccess,\n  req,\n}: Args) => {\n  if (joinsQuery === false) {\n    return false\n  }\n\n  if (!joinsQuery) {\n    joinsQuery = {}\n  }\n\n  const errors: { path: string }[] = []\n  const promises: Promise<void>[] = []\n\n  for (const collectionSlug in collectionConfig.joins) {\n    for (const join of collectionConfig.joins[collectionSlug]) {\n      await sanitizeJoinFieldQuery({\n        collectionSlug,\n        errors,\n        join,\n        joinsQuery,\n        overrideAccess,\n        promises,\n        req,\n      })\n    }\n  }\n\n  for (const join of collectionConfig.polymorphicJoins) {\n    for (const collectionSlug of join.field.collection) {\n      await sanitizeJoinFieldQuery({\n        collectionSlug,\n        errors,\n        join,\n        joinsQuery,\n        overrideAccess,\n        promises,\n        req,\n      })\n    }\n  }\n\n  await Promise.all(promises)\n\n  if (errors.length > 0) {\n    throw new QueryError(errors)\n  }\n\n  return joinsQuery\n}\n"],"names":["executeAccess","QueryError","combineQueries","validateQueryPaths","sanitizeJoinFieldQuery","collectionSlug","errors","join","joinsQuery","overrideAccess","promises","req","joinPath","joinCollectionConfig","payload","collections","config","accessResult","disableErrors","access","read","joinQuery","where","field","push","collectionConfig","polymorphicJoin","Array","isArray","collection","sanitizeJoinQuery","joins","polymorphicJoins","Promise","all","length"],"mappings":"AAAA,oBAAoB;AAKpB,OAAOA,mBAAmB,2BAA0B;AACpD,SAASC,UAAU,QAAQ,0BAAyB;AACpD,SAASC,cAAc,QAAQ,sBAAqB;AACpD,SAASC,kBAAkB,QAAQ,0CAAyC;AAS5E,MAAMC,yBAAyB,OAAO,EACpCC,cAAc,EACdC,MAAM,EACNC,IAAI,EACJC,UAAU,EACVC,cAAc,EACdC,QAAQ,EACRC,GAAG,EASJ;IACC,MAAM,EAAEC,QAAQ,EAAE,GAAGL;IAErB,IAAIC,UAAU,CAACI,SAAS,KAAK,OAAO;QAClC;IACF;IAEA,MAAMC,uBAAuBF,IAAIG,OAAO,CAACC,WAAW,CAACV,eAAe,CAACW,MAAM;IAE3E,MAAMC,eAAe,CAACR,iBAClB,MAAMT,cAAc;QAAEkB,eAAe;QAAMP;IAAI,GAAGE,qBAAqBM,MAAM,CAACC,IAAI,IAClF;IAEJ,IAAIH,iBAAiB,OAAO;QAC1BT,UAAU,CAACI,SAAS,GAAG;QACvB;IACF;IAEA,IAAI,CAACJ,UAAU,CAACI,SAAS,EAAE;QACzBJ,UAAU,CAACI,SAAS,GAAG,CAAC;IAC1B;IAEA,MAAMS,YAAYb,UAAU,CAACI,SAAS;IAEtC,IAAI,CAACS,UAAUC,KAAK,EAAE;QACpBD,UAAUC,KAAK,GAAG,CAAC;IACrB;IAEA,IAAIf,KAAKgB,KAAK,CAACD,KAAK,EAAE;QACpBD,UAAUC,KAAK,GAAGpB,eAAemB,UAAUC,KAAK,EAAEf,KAAKgB,KAAK,CAACD,KAAK;IACpE;IAEAZ,SAASc,IAAI,CACXrB,mBAAmB;QACjBsB,kBAAkBZ;QAClBP;QACAG;QACAiB,iBAAiBC,MAAMC,OAAO,CAACrB,KAAKgB,KAAK,CAACM,UAAU;QACpDlB;QACA,qFAAqF;QACrFW,OAAOD,UAAUC,KAAK;IACxB;IAGF,IAAI,OAAOL,iBAAiB,UAAU;QACpCI,UAAUC,KAAK,GAAGpB,eAAemB,UAAUC,KAAK,EAAEL;IACpD;AACF;AAEA;;;;CAIC,GACD,OAAO,MAAMa,oBAAoB,OAAO,EACtCL,gBAAgB,EAChBM,OAAOvB,UAAU,EACjBC,cAAc,EACdE,GAAG,EACE;IACL,IAAIH,eAAe,OAAO;QACxB,OAAO;IACT;IAEA,IAAI,CAACA,YAAY;QACfA,aAAa,CAAC;IAChB;IAEA,MAAMF,SAA6B,EAAE;IACrC,MAAMI,WAA4B,EAAE;IAEpC,IAAK,MAAML,kBAAkBoB,iBAAiBM,KAAK,CAAE;QACnD,KAAK,MAAMxB,QAAQkB,iBAAiBM,KAAK,CAAC1B,eAAe,CAAE;YACzD,MAAMD,uBAAuB;gBAC3BC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,KAAK,MAAMJ,QAAQkB,iBAAiBO,gBAAgB,CAAE;QACpD,KAAK,MAAM3B,kBAAkBE,KAAKgB,KAAK,CAACM,UAAU,CAAE;YAClD,MAAMzB,uBAAuB;gBAC3BC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;gBACAC;YACF;QACF;IACF;IAEA,MAAMsB,QAAQC,GAAG,CAACxB;IAElB,IAAIJ,OAAO6B,MAAM,GAAG,GAAG;QACrB,MAAM,IAAIlC,WAAWK;IACvB;IAEA,OAAOE;AACT,EAAC"}