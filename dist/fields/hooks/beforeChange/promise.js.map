{"version":3,"sources":["../../../../src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField, Validate } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { getTranslatedLabel } from '../../../utilities/getTranslatedLabel.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\nfunction buildFieldLabel(parentLabel: string, label: string): string {\n  const capitalizedLabel = label.charAt(0).toUpperCase() + label.slice(1)\n  return parentLabel && capitalizedLabel\n    ? `${parentLabel} > ${capitalizedLabel}`\n    : capitalizedLabel || parentLabel\n}\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * Built up labels of parent fields\n   *\n   * @example \"Group Field > Tab Field > Text Field\"\n   */\n  fieldLabelPath: string\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void> | void)[]\n  operation: Operation\n  overrideAccess: boolean\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  fieldIndex,\n  fieldLabelPath,\n  global,\n  mergeLocaleActions,\n  operation,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  siblingFields,\n  skipValidation,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  const passesCondition = field.admin?.condition\n    ? Boolean(\n        field.admin.condition(data, siblingData, {\n          blockData,\n          operation,\n          path: pathSegments,\n          user: req.user,\n        }),\n      )\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      for (const hook of field.hooks.beforeChange) {\n        const hookedValue = await hook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingDocWithLocales,\n          siblingFields,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validateFn: Validate<object, object, object, object> = field.validate as Validate<\n        object,\n        object,\n        object,\n        object\n      >\n\n      const validationResult = await validateFn(valueToValidate as never, {\n        ...field,\n        id,\n        blockData,\n        collectionSlug: collection?.slug,\n        data: deepMergeWithSourceArrays(doc, data),\n        event: 'submit',\n        // @ts-expect-error\n        jsonError,\n        operation,\n        overrideAccess,\n        path: pathSegments,\n        preferences: { fields: {} },\n        previousValue: siblingDoc[field.name],\n        req,\n        siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n      })\n\n      if (typeof validationResult === 'string') {\n        const fieldLabel = buildFieldLabel(\n          fieldLabelPath,\n          getTranslatedLabel(field?.label || field?.name, req.i18n),\n        )\n\n        errors.push({\n          label: fieldLabel,\n          message: validationResult,\n          path,\n        })\n      }\n    }\n\n    // Push merge locale action if applicable\n    if (localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n      mergeLocaleActions.push(() => {\n        const localeData = {}\n\n        for (const locale of localization.localeCodes) {\n          const fieldValue =\n            locale === req.locale\n              ? siblingData[field.name]\n              : siblingDocWithLocales?.[field.name]?.[locale]\n\n          // update locale value if it's not undefined\n          if (typeof fieldValue !== 'undefined') {\n            localeData[locale] = fieldValue\n          }\n        }\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fieldLabelPath:\n                field?.label === false\n                  ? fieldLabelPath\n                  : buildFieldLabel(\n                      fieldLabelPath,\n                      `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,\n                    ),\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fieldLabelPath:\n                  field?.label === false\n                    ? fieldLabelPath\n                    : buildFieldLabel(\n                        fieldLabelPath,\n                        `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,\n                      ),\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field.type === 'row' || field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field?.type, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'group': {\n      let groupSiblingData = siblingData\n      let groupSiblingDoc = siblingDoc\n      let groupSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedGroup = fieldAffectsData(field)\n\n      if (isNamedGroup) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        groupSiblingData = siblingData[field.name] as JsonObject\n        groupSiblingDoc = siblingDoc[field.name] as JsonObject\n        groupSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      const fallbackLabel = field?.label || (isNamedGroup ? field.name : field?.type)\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(fieldLabelPath, getTranslatedLabel(fallbackLabel, req.i18n)),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedGroup ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedGroup ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: groupSiblingData,\n        siblingDoc: groupSiblingDoc,\n        siblingDocWithLocales: groupSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        for (const hook of editor.hooks.beforeChange) {\n          const hookedValue = await hook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            fieldLabelPath:\n              field?.label === false\n                ? fieldLabelPath\n                : buildFieldLabel(\n                    fieldLabelPath,\n                    getTranslatedLabel(field?.label || field?.name, req.i18n),\n                  ),\n            global,\n            indexPath: indexPathSegments,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            overrideAccess,\n            parentIsLocalized,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field?.name, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(fieldLabelPath, getTranslatedLabel(field?.label || '', req.i18n)),\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","deepMergeWithSourceArrays","getTranslatedLabel","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getFieldPathsModified","getFieldPaths","getExistingRowDoc","traverseFields","buildFieldLabel","parentLabel","label","capitalizedLabel","charAt","toUpperCase","slice","promise","id","blockData","collection","context","data","doc","docWithLocales","errors","field","fieldIndex","fieldLabelPath","global","mergeLocaleActions","operation","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","siblingFields","skipValidation","indexPath","path","schemaPath","index","localization","payload","config","defaultLocale","operationLocale","locale","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","passesCondition","admin","condition","user","skipValidationFromHere","includes","type","name","hooks","beforeChange","hook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","validate","valueToValidate","jsonError","JSON","parse","e","validateFn","validationResult","collectionSlug","slug","event","preferences","fields","fieldLabel","i18n","push","message","localeData","localeCodes","fieldValue","Object","keys","length","rows","Array","isArray","promises","forEach","row","rowIndex","localized","Promise","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","groupSiblingData","groupSiblingDoc","groupSiblingDocWithLocales","isNamedGroup","fallbackLabel","coordinates","parseFloat","editor","Error","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","isNamedTab","tabs","tab"],"mappings":"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"}