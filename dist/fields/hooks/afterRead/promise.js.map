{"version":3,"sources":["../../../../src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { type RequestContext } from '../../../index.js'\nimport { getBlockSelect } from '../../../utilities/getBlockSelect.js'\nimport { stripUnselectedFields } from '../../../utilities/stripUnselectedFields.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\nimport { virtualFieldPopulationPromise } from './virtualFieldPopulationPromise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldIndex,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  siblingFields,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  if (\n    fieldAffectsData(field) &&\n    field.hidden &&\n    typeof siblingDoc[field.name] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    delete siblingDoc[field.name]\n  }\n\n  if (path !== 'id') {\n    const shouldContinue = stripUnselectedFields({\n      field,\n      select,\n      selectMode,\n      siblingDoc,\n    })\n\n    if (!shouldContinue) {\n      return\n    }\n  }\n\n  const shouldHoistLocalizedValue =\n    flattenLocales &&\n    fieldAffectsData(field) &&\n    typeof siblingDoc[field.name] === 'object' &&\n    siblingDoc[field.name] !== null &&\n    fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n    locale !== 'all' &&\n    req.payload.config.localization\n\n  if (shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name][locale]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (fieldAffectsData(field) && typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsData(field)) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      for (const hook of field.hooks.afterRead) {\n        const shouldRunHookOnAllLocales =\n          fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const localesAndValues = Object.entries(siblingDoc[field.name])\n          await Promise.all(\n            localesAndValues.map(async ([localeKey, value]) => {\n              const hookedValue = await hook({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                indexPath: indexPathSegments,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: pathSegments,\n                req,\n                schemaPath: schemaPathSegments,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                siblingFields,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name][localeKey] = hookedValue\n              }\n            }),\n          )\n        } else {\n          const hookedValue = await hook({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            indexPath: indexPathSegments,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: pathSegments,\n            req,\n            schemaPath: schemaPathSegments,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            siblingFields,\n            value: siblingDoc[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name] = hookedValue\n          }\n        }\n      }\n    }\n\n    if ('virtual' in field && typeof field.virtual === 'string') {\n      populationPromises.push(\n        virtualFieldPopulationPromise({\n          name: field.name,\n          draft,\n          fallbackLocale,\n          fields: (collection || global).flattenedFields,\n          locale,\n          overrideAccess,\n          ref: doc,\n          req,\n          segments: field.virtual.split('.'),\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const result = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            blockData,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!result) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      allowDefaultValue &&\n      typeof siblingDoc[field.name] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale,\n        req,\n        user: req.user,\n        value: siblingDoc[field.name],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          parentIsLocalized,\n          populate,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      let arraySelect = select?.[field.name]\n\n      if (selectMode === 'include' && typeof arraySelect === 'object') {\n        arraySelect = {\n          ...arraySelect,\n          id: true,\n        }\n      }\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, rowIndex) => {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path + '.' + rowIndex,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: typeof arraySelect === 'object' ? arraySelect : undefined,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              traverseFields({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath,\n                populate,\n                populationPromises,\n                req,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows)) {\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          const { blockSelect, blockSelectMode } = getBlockSelect({\n            block,\n            select: select?.[field.name],\n            selectMode,\n          })\n\n          if (block) {\n            traverseFields({\n              blockData: row,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath + '.' + block.slug,\n              populate,\n              populationPromises,\n              req,\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n\n              const block: Block | undefined =\n                req.payload.blocks[blockTypeToMatch] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                ) as Block | undefined)\n\n              if (block) {\n                traverseFields({\n                  blockData: row,\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  populate,\n                  populationPromises,\n                  req,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (fieldAffectsData(field)) {\n        let groupDoc = siblingDoc[field.name] as JsonObject\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          groupDoc = {}\n        }\n\n        const groupSelect = select?.[field.name]\n\n        traverseFields({\n          blockData,\n          collection,\n          context,\n          currentDepth,\n          depth,\n          doc,\n          draft,\n          fallbackLocale,\n          fieldPromises,\n          fields: field.fields,\n          findMany,\n          flattenLocales,\n          global,\n          locale,\n          overrideAccess,\n          parentIndexPath: '',\n          parentIsLocalized: parentIsLocalized || field.localized,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          populate,\n          populationPromises,\n          req,\n          select: typeof groupSelect === 'object' ? groupSelect : undefined,\n          selectMode,\n          showHiddenFields,\n          siblingDoc: groupDoc,\n          triggerAccessControl,\n          triggerHooks,\n        })\n      } else {\n        traverseFields({\n          blockData,\n          collection,\n          context,\n          currentDepth,\n          depth,\n          doc,\n          draft,\n          fallbackLocale,\n          fieldPromises,\n          fields: field.fields,\n          findMany,\n          flattenLocales,\n          global,\n          locale,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          populate,\n          populationPromises,\n          req,\n          select,\n          selectMode,\n          showHiddenFields,\n          siblingDoc,\n          triggerAccessControl,\n          triggerHooks,\n        })\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        for (const hook of editor.hooks.afterRead) {\n          const shouldRunHookOnAllLocales =\n            fieldShouldBeLocalized({ field, parentIsLocalized }) &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const localesAndValues = Object.entries(siblingDoc[field.name])\n\n            await Promise.all(\n              localesAndValues.map(async ([locale, value]) => {\n                const hookedValue = await hook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  indexPath: indexPathSegments,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  parentIsLocalized,\n                  path: pathSegments,\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: schemaPathSegments,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              }),\n            )\n          } else {\n            const hookedValue = await hook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath: indexPathSegments,\n              locale,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              parentIsLocalized,\n              path: pathSegments,\n              populate,\n              populationPromises,\n              req,\n              schemaPath: schemaPathSegments,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      let tabSelect: SelectType | undefined\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabDoc = siblingDoc[field.name] as JsonObject\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          tabDoc = {}\n        }\n\n        if (typeof select?.[field.name] === 'object') {\n          tabSelect = select?.[field.name] as SelectType\n        }\n      } else {\n        tabSelect = select\n      }\n\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select: tabSelect,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","getBlockSelect","stripUnselectedFields","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getDefaultValue","getFieldPathsModified","getFieldPaths","relationshipPopulationPromise","traverseFields","virtualFieldPopulationPromise","promise","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldIndex","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","siblingFields","triggerAccessControl","triggerHooks","indexPath","path","schemaPath","index","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","hidden","name","shouldContinue","shouldHoistLocalizedValue","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","pointDoc","Array","isArray","coordinates","length","undefined","editor","Error","tabs","forEach","tab","hooks","afterRead","hook","shouldRunHookOnAllLocales","localesAndValues","Object","entries","Promise","all","localeKey","hookedValue","data","operation","originalDoc","siblingData","virtual","push","fields","flattenedFields","ref","segments","allowDefaultValue","access","read","result","id","defaultValue","user","rows","arraySelect","row","rowIndex","localized","values","localeRows","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","slug","blockSelect","blockSelectMode","groupDoc","groupSelect","tabDoc","tabSelect","isNamedTab"],"mappings":"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"}