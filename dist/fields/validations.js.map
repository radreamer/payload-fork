{"version":3,"sources":["../../src/fields/validations.ts"],"sourcesContent":["// @ts-strict-ignore\nimport Ajv from 'ajv'\nimport ObjectIdImport from 'bson-objectid'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nimport type { RichTextAdapter } from '../admin/types.js'\nimport type { CollectionSlug } from '../index.js'\nimport type { Where } from '../types/index.js'\nimport type {\n  ArrayField,\n  BlocksField,\n  CheckboxField,\n  CodeField,\n  DateField,\n  EmailField,\n  JSONField,\n  NumberField,\n  PointField,\n  RadioField,\n  RelationshipField,\n  RelationshipValue,\n  RelationshipValueMany,\n  RelationshipValueSingle,\n  RichTextField,\n  SelectField,\n  TextareaField,\n  TextField,\n  UploadField,\n  Validate,\n} from './config/types.js'\n\nimport { isNumber } from '../utilities/isNumber.js'\nimport { isValidID } from '../utilities/isValidID.js'\n\nexport type TextFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport type TextFieldManyValidation = Validate<string[], unknown, unknown, TextField>\n\nexport type TextFieldSingleValidation = Validate<string, unknown, unknown, TextField>\n\nexport const text: TextFieldValidation = (\n  value,\n  {\n    hasMany,\n    maxLength: fieldMaxLength,\n    maxRows,\n    minLength,\n    minRows,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (!required) {\n    if (!value) {\n      return true\n    }\n  }\n\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  const stringsToValidate: string[] = Array.isArray(value) ? value : [value]\n\n  for (const stringValue of stringsToValidate) {\n    const length = stringValue?.length || 0\n\n    if (typeof maxLength === 'number' && length > maxLength) {\n      return t('validation:shorterThanMax', { label: t('general:value'), maxLength, stringValue })\n    }\n\n    if (typeof minLength === 'number' && length < minLength) {\n      return t('validation:longerThanMin', { label: t('general:value'), minLength, stringValue })\n    }\n  }\n\n  if (required) {\n    if (!(typeof value === 'string' || Array.isArray(value)) || value?.length === 0) {\n      return t('validation:required')\n    }\n  }\n\n  return true\n}\n\nexport type PasswordFieldValidation = Validate<string, unknown, unknown, TextField>\n\nexport const password: PasswordFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength = 3,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type ConfirmPasswordFieldValidation = Validate<\n  string,\n  unknown,\n  { password: string },\n  TextField\n>\n\nexport const confirmPassword: ConfirmPasswordFieldValidation = (\n  value,\n  { req: { t }, required, siblingData },\n) => {\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (value && value !== siblingData.password) {\n    return t('fields:passwordsDoNotMatch')\n  }\n\n  return true\n}\n\nexport type EmailFieldValidation = Validate<string, unknown, { username?: string }, EmailField>\n\nexport const email: EmailFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.username) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  /**\n   * Disallows emails with double quotes (e.g., \"user\"@example.com, user@\"example.com\", \"user@example.com\")\n   * Rejects spaces anywhere in the email (e.g., user @example.com, user@ example.com, user name@example.com)\n   * Prevents consecutive dots in the local or domain part (e.g., user..name@example.com, user@example..com)\n   * Disallows domains that start or end with a hyphen (e.g., user@-example.com, user@example-.com)\n   * Allows standard email formats (e.g., user@example.com, user.name+alias@example.co.uk, user-name@example.org)\n   * Allows domains with consecutive hyphens as long as they are not leading/trailing (e.g., user@ex--ample.com)\n   * Supports multiple subdomains (e.g., user@sub.domain.example.com)\n   */\n  const emailRegex =\n    /^(?!.*\\.\\.)[\\w!#$%&'*+/=?^`{|}~-](?:[\\w!#$%&'*+/=?^`{|}~.-]*[\\w!#$%&'*+/=?^`{|}~-])?@[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)*\\.[a-z]{2,}$/i\n\n  if ((value && !emailRegex.test(value)) || (!value && required)) {\n    return t('validation:emailAddress')\n  }\n\n  return true\n}\n\nexport type UsernameFieldValidation = Validate<string, unknown, { email?: string }, TextField>\n\nexport const username: UsernameFieldValidation = (\n  value,\n  {\n    collectionSlug,\n    req: {\n      payload: { collections, config },\n      t,\n    },\n    required,\n    siblingData,\n  },\n) => {\n  let maxLength: number\n\n  if (collectionSlug) {\n    const collection =\n      collections?.[collectionSlug]?.config ??\n      config.collections.find(({ slug }) => slug === collectionSlug) // If this is run on the client, `collections` will be undefined, but `config.collections` will be available\n\n    if (\n      collection.auth.loginWithUsername &&\n      !collection.auth.loginWithUsername?.requireUsername &&\n      !collection.auth.loginWithUsername?.requireEmail\n    ) {\n      if (!value && !siblingData?.email) {\n        return t('validation:required')\n      }\n    }\n  }\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (!value && required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type TextareaFieldValidation = Validate<string, unknown, unknown, TextareaField>\n\nexport const textarea: TextareaFieldValidation = (\n  value,\n  {\n    maxLength: fieldMaxLength,\n    minLength,\n    req: {\n      payload: { config },\n      t,\n    },\n    required,\n  },\n) => {\n  let maxLength: number\n\n  if (typeof config?.defaultMaxTextLength === 'number') {\n    maxLength = config.defaultMaxTextLength\n  }\n  if (typeof fieldMaxLength === 'number') {\n    maxLength = fieldMaxLength\n  }\n  if (value && maxLength && value.length > maxLength) {\n    return t('validation:shorterThanMax', { maxLength })\n  }\n\n  if (value && minLength && value.length < minLength) {\n    return t('validation:longerThanMin', { minLength })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type CodeFieldValidation = Validate<string, unknown, unknown, CodeField>\n\nexport const code: CodeFieldValidation = (value, { req: { t }, required }) => {\n  if (required && value === undefined) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type JSONFieldValidation = Validate<\n  string,\n  unknown,\n  unknown,\n  { jsonError?: string } & JSONField\n>\n\nexport const json: JSONFieldValidation = async (\n  value,\n  { jsonError, jsonSchema, req: { t }, required },\n) => {\n  const isNotEmpty = (value) => {\n    if (value === undefined || value === null) {\n      return false\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false\n    }\n\n    if (typeof value === 'object' && Object.keys(value).length === 0) {\n      return false\n    }\n\n    return true\n  }\n\n  const fetchSchema = ({ schema, uri }: Record<string, unknown>) => {\n    if (uri && schema) {\n      return schema\n    }\n    // @ts-expect-error\n    return fetch(uri)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error('Network response was not ok')\n        }\n        return response.json()\n      })\n      .then((json) => {\n        const jsonSchemaSanitizations = {\n          id: undefined,\n          $id: json.id,\n          $schema: 'http://json-schema.org/draft-07/schema#',\n        }\n\n        return Object.assign(json, jsonSchemaSanitizations)\n      })\n  }\n\n  if (required && !value) {\n    return t('validation:required')\n  }\n\n  if (jsonError !== undefined) {\n    return t('validation:invalidInput')\n  }\n\n  if (jsonSchema && isNotEmpty(value)) {\n    try {\n      jsonSchema.schema = await fetchSchema(jsonSchema)\n      const { schema } = jsonSchema\n      // @ts-expect-error\n      const ajv = new Ajv()\n\n      if (!ajv.validate(schema, value)) {\n        return ajv.errorsText()\n      }\n    } catch (error) {\n      return error.message\n    }\n  }\n  return true\n}\n\nexport type CheckboxFieldValidation = Validate<boolean, unknown, unknown, CheckboxField>\n\nexport const checkbox: CheckboxFieldValidation = (value, { req: { t }, required }) => {\n  if ((value && typeof value !== 'boolean') || (required && typeof value !== 'boolean')) {\n    return t('validation:trueOrFalse')\n  }\n\n  return true\n}\n\nexport type DateFieldValidation = Validate<Date, unknown, unknown, DateField>\n\nexport const date: DateFieldValidation = (\n  value,\n  { name, req: { t }, required, siblingData, timezone },\n) => {\n  const validDate = value && !isNaN(Date.parse(value.toString()))\n\n  // We need to also check for the timezone data based on this field's config\n  // We cannot do this inside the timezone field validation as it's visually hidden\n  const hasRequiredTimezone = timezone && required\n  const selectedTimezone: string = siblingData?.[`${name}_tz`]\n  // Always resolve to true if the field is not required, as timezone may be optional too then\n  const validTimezone = hasRequiredTimezone ? Boolean(selectedTimezone) : true\n\n  if (validDate && validTimezone) {\n    return true\n  }\n\n  if (validDate && !validTimezone) {\n    return t('validation:timezoneRequired')\n  }\n\n  if (value) {\n    return t('validation:notValidDate', { value })\n  }\n\n  if (required) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RichTextFieldValidation = Validate<object, unknown, unknown, RichTextField>\n\nexport const richText: RichTextFieldValidation = async (value, options) => {\n  if (!options?.editor) {\n    throw new Error('richText field has no editor property.')\n  }\n  if (typeof options?.editor === 'function') {\n    throw new Error('Attempted to access unsanitized rich text editor.')\n  }\n\n  const editor: RichTextAdapter = options?.editor\n\n  return editor.validate(value, options)\n}\n\nconst validateArrayLength = (\n  value,\n  options: {\n    maxRows?: number\n    minRows?: number\n    required?: boolean\n    t: (key: string, options?: { [key: string]: number | string }) => string\n  },\n) => {\n  const { maxRows, minRows, required, t } = options\n\n  const arrayLength = Array.isArray(value) ? value.length : value || 0\n\n  if (!required && arrayLength === 0) {\n    return true\n  }\n\n  if (minRows && arrayLength < minRows) {\n    return t('validation:requiresAtLeast', { count: minRows, label: t('general:rows') })\n  }\n\n  if (maxRows && arrayLength > maxRows) {\n    return t('validation:requiresNoMoreThan', { count: maxRows, label: t('general:rows') })\n  }\n\n  if (required && !arrayLength) {\n    return t('validation:requiresAtLeast', { count: 1, label: t('general:row') })\n  }\n\n  return true\n}\n\nexport type NumberFieldValidation = Validate<number | number[], unknown, unknown, NumberField>\n\nexport type NumberFieldManyValidation = Validate<number[], unknown, unknown, NumberField>\n\nexport type NumberFieldSingleValidation = Validate<number, unknown, unknown, NumberField>\n\nexport const number: NumberFieldValidation = (\n  value,\n  { hasMany, max, maxRows, min, minRows, req: { t }, required },\n) => {\n  if (hasMany === true) {\n    const lengthValidationResult = validateArrayLength(value, { maxRows, minRows, required, t })\n    if (typeof lengthValidationResult === 'string') {\n      return lengthValidationResult\n    }\n  }\n\n  if (!value && !isNumber(value)) {\n    // if no value is present, validate based on required\n    if (required) {\n      return t('validation:required')\n    }\n    if (!required) {\n      return true\n    }\n  }\n\n  const numbersToValidate: number[] = Array.isArray(value) ? value : [value]\n\n  for (const number of numbersToValidate) {\n    if (!isNumber(number)) {\n      return t('validation:enterNumber')\n    }\n\n    const numberValue = parseFloat(number as unknown as string)\n\n    if (typeof max === 'number' && numberValue > max) {\n      return t('validation:greaterThanMax', { label: t('general:value'), max, value })\n    }\n\n    if (typeof min === 'number' && numberValue < min) {\n      return t('validation:lessThanMin', { label: t('general:value'), min, value })\n    }\n  }\n\n  return true\n}\n\nexport type ArrayFieldValidation = Validate<unknown[], unknown, unknown, ArrayField>\n\nexport const array: ArrayFieldValidation = (value, { maxRows, minRows, req: { t }, required }) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nexport type BlocksFieldValidation = Validate<unknown, unknown, unknown, BlocksField>\n\nexport const blocks: BlocksFieldValidation = (\n  value,\n  { maxRows, minRows, req: { t }, required },\n) => {\n  return validateArrayLength(value, { maxRows, minRows, required, t })\n}\n\nconst validateFilterOptions: Validate<\n  unknown,\n  unknown,\n  unknown,\n  RelationshipField | UploadField\n> = async (\n  value,\n  { id, blockData, data, filterOptions, relationTo, req, req: { payload, t, user }, siblingData },\n) => {\n  if (typeof filterOptions !== 'undefined' && value) {\n    const options: {\n      [collection: string]: (number | string)[]\n    } = {}\n\n    const falseCollections: CollectionSlug[] = []\n    const collections = !Array.isArray(relationTo) ? [relationTo] : relationTo\n    const values = Array.isArray(value) ? value : [value]\n\n    for (const collection of collections) {\n      try {\n        let optionFilter =\n          typeof filterOptions === 'function'\n            ? await filterOptions({\n                id,\n                blockData,\n                data,\n                relationTo: collection,\n                req,\n                siblingData,\n                user,\n              })\n            : filterOptions\n\n        if (optionFilter === true) {\n          optionFilter = null\n        }\n\n        const valueIDs: (number | string)[] = []\n\n        values.forEach((val) => {\n          if (typeof val === 'object') {\n            if (val?.value) {\n              valueIDs.push(val.value)\n            } else if (ObjectId.isValid(val)) {\n              valueIDs.push(new ObjectId(val).toHexString())\n            }\n          }\n\n          if (typeof val === 'string' || typeof val === 'number') {\n            valueIDs.push(val)\n          }\n        })\n\n        if (valueIDs.length > 0) {\n          const findWhere: Where = {\n            and: [{ id: { in: valueIDs } }],\n          }\n\n          if (optionFilter && optionFilter !== true) {\n            findWhere.and.push(optionFilter)\n          }\n\n          if (optionFilter === false) {\n            falseCollections.push(collection)\n          }\n\n          const result = await req.payloadDataLoader.find({\n            collection,\n            depth: 0,\n            limit: 0,\n            pagination: false,\n            req,\n            where: findWhere,\n          })\n\n          options[collection] = result.docs.map((doc) => doc.id)\n        } else {\n          options[collection] = []\n        }\n      } catch (err) {\n        req.payload.logger.error({\n          err,\n          msg: `Error validating filter options for collection ${collection}`,\n        })\n        options[collection] = []\n      }\n    }\n\n    const invalidRelationships = values.filter((val) => {\n      let collection: string\n      let requestedID: number | string\n\n      if (typeof relationTo === 'string') {\n        collection = relationTo\n\n        if (typeof val === 'string' || typeof val === 'number') {\n          requestedID = val\n        }\n\n        if (typeof val === 'object' && ObjectId.isValid(val)) {\n          requestedID = new ObjectId(val).toHexString()\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collection = val.relationTo\n        requestedID = val.value\n      }\n\n      if (falseCollections.find((slug) => relationTo === slug)) {\n        return true\n      }\n\n      if (!options[collection]) {\n        return true\n      }\n\n      return options[collection].indexOf(requestedID) === -1\n    })\n\n    if (invalidRelationships.length > 0) {\n      return invalidRelationships.reduce((err, invalid, i) => {\n        return `${err} ${JSON.stringify(invalid)}${\n          invalidRelationships.length === i + 1 ? ',' : ''\n        } `\n      }, t('validation:invalidSelections')) as string\n    }\n\n    return true\n  }\n\n  return true\n}\n\nexport type UploadFieldValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport type UploadFieldManyValidation = Validate<unknown[], unknown, unknown, UploadField>\n\nexport type UploadFieldSingleValidation = Validate<unknown, unknown, unknown, UploadField>\n\nexport const upload: UploadFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type RelationshipFieldValidation = Validate<\n  RelationshipValue,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldManyValidation = Validate<\n  RelationshipValueMany,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport type RelationshipFieldSingleValidation = Validate<\n  RelationshipValueSingle,\n  unknown,\n  unknown,\n  RelationshipField\n>\n\nexport const relationship: RelationshipFieldValidation = async (value, options) => {\n  const {\n    event,\n    maxRows,\n    minRows,\n    relationTo,\n    req: { payload, t },\n    required,\n  } = options\n\n  if (\n    ((!value && typeof value !== 'number') || (Array.isArray(value) && value.length === 0)) &&\n    required\n  ) {\n    return t('validation:required')\n  }\n\n  if (Array.isArray(value) && value.length > 0) {\n    if (minRows && value.length < minRows) {\n      return t('validation:lessThanMin', {\n        label: t('general:rows'),\n        min: minRows,\n        value: value.length,\n      })\n    }\n\n    if (maxRows && value.length > maxRows) {\n      return t('validation:greaterThanMax', {\n        label: t('general:rows'),\n        max: maxRows,\n        value: value.length,\n      })\n    }\n  }\n\n  if (typeof value !== 'undefined' && value !== null) {\n    const values = Array.isArray(value) ? value : [value]\n\n    const invalidRelationships = values.filter((val) => {\n      let collectionSlug: string\n      let requestedID\n\n      if (typeof relationTo === 'string') {\n        collectionSlug = relationTo\n\n        // custom id\n        if (val || typeof val === 'number') {\n          requestedID = val\n        }\n      }\n\n      if (Array.isArray(relationTo) && typeof val === 'object' && val?.relationTo) {\n        collectionSlug = val.relationTo\n        requestedID = val.value\n      }\n\n      if (requestedID === null) {\n        return false\n      }\n\n      const idType =\n        payload.collections[collectionSlug]?.customIDType || payload?.db?.defaultIDType || 'text'\n\n      return !isValidID(requestedID, idType)\n    })\n\n    if (invalidRelationships.length > 0) {\n      return `This relationship field has the following invalid relationships: ${invalidRelationships\n        .map((err, invalid) => {\n          return `${err} ${JSON.stringify(invalid)}`\n        })\n        .join(', ')}`\n    }\n  }\n\n  if (event === 'onChange') {\n    return true\n  }\n\n  return validateFilterOptions(value, options)\n}\n\nexport type SelectFieldValidation = Validate<string | string[], unknown, unknown, SelectField>\n\nexport type SelectFieldManyValidation = Validate<string[], unknown, unknown, SelectField>\n\nexport type SelectFieldSingleValidation = Validate<string, unknown, unknown, SelectField>\n\nexport const select: SelectFieldValidation = (\n  value,\n  { hasMany, options, req: { t }, required },\n) => {\n  if (\n    Array.isArray(value) &&\n    value.some(\n      (input) =>\n        !options.some(\n          (option) => option === input || (typeof option !== 'string' && option?.value === input),\n        ),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    typeof value === 'string' &&\n    !options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n  ) {\n    return t('validation:invalidSelection')\n  }\n\n  if (\n    required &&\n    (typeof value === 'undefined' ||\n      value === null ||\n      (hasMany && Array.isArray(value) && (value as [])?.length === 0))\n  ) {\n    return t('validation:required')\n  }\n\n  return true\n}\n\nexport type RadioFieldValidation = Validate<unknown, unknown, unknown, RadioField>\n\nexport const radio: RadioFieldValidation = (value, { options, req: { t }, required }) => {\n  if (value) {\n    const valueMatchesOption = options.some(\n      (option) => option === value || (typeof option !== 'string' && option.value === value),\n    )\n    return valueMatchesOption || t('validation:invalidSelection')\n  }\n\n  return required ? t('validation:required') : true\n}\n\nexport type PointFieldValidation = Validate<\n  [number | string, number | string],\n  unknown,\n  unknown,\n  PointField\n>\n\nexport const point: PointFieldValidation = (value = ['', ''], { req: { t }, required }) => {\n  const lng = parseFloat(String(value[0]))\n  const lat = parseFloat(String(value[1]))\n  if (\n    required &&\n    ((value[0] && value[1] && typeof lng !== 'number' && typeof lat !== 'number') ||\n      Number.isNaN(lng) ||\n      Number.isNaN(lat) ||\n      (Array.isArray(value) && value.length !== 2))\n  ) {\n    return t('validation:requiresTwoNumbers')\n  }\n\n  if ((value[1] && Number.isNaN(lng)) || (value[0] && Number.isNaN(lat))) {\n    return t('validation:invalidInput')\n  }\n\n  return true\n}\n\n/**\n * Built-in field validations used by Payload\n *\n * These can be re-used in custom validations\n */\nexport const validations = {\n  array,\n  blocks,\n  checkbox,\n  code,\n  confirmPassword,\n  date,\n  email,\n  json,\n  number,\n  password,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  text,\n  textarea,\n  upload,\n}\n"],"names":["Ajv","ObjectIdImport","ObjectId","default","isNumber","isValidID","text","value","hasMany","maxLength","fieldMaxLength","maxRows","minLength","minRows","req","payload","config","t","required","lengthValidationResult","validateArrayLength","defaultMaxTextLength","stringsToValidate","Array","isArray","stringValue","length","label","password","confirmPassword","siblingData","email","collectionSlug","collections","collection","find","slug","auth","loginWithUsername","requireUsername","requireEmail","username","emailRegex","test","textarea","code","undefined","json","jsonError","jsonSchema","isNotEmpty","Object","keys","fetchSchema","schema","uri","fetch","then","response","ok","Error","jsonSchemaSanitizations","id","$id","$schema","assign","ajv","validate","errorsText","error","message","checkbox","date","name","timezone","validDate","isNaN","Date","parse","toString","hasRequiredTimezone","selectedTimezone","validTimezone","Boolean","richText","options","editor","arrayLength","count","number","max","min","numbersToValidate","numberValue","parseFloat","array","blocks","validateFilterOptions","blockData","data","filterOptions","relationTo","user","falseCollections","values","optionFilter","valueIDs","forEach","val","push","isValid","toHexString","findWhere","and","in","result","payloadDataLoader","depth","limit","pagination","where","docs","map","doc","err","logger","msg","invalidRelationships","filter","requestedID","indexOf","reduce","invalid","i","JSON","stringify","upload","event","idType","customIDType","db","defaultIDType","join","relationship","select","some","input","option","radio","valueMatchesOption","point","lng","String","lat","Number","validations"],"mappings":"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"}