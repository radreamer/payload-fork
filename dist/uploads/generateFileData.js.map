{"version":3,"sources":["../../src/uploads/generateFileData.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { OutputInfo, Sharp, SharpOptions } from 'sharp'\n\nimport { fileTypeFromBuffer } from 'file-type'\nimport fs from 'fs/promises'\nimport sanitize from 'sanitize-filename'\n\nimport type { Collection } from '../collections/config/types.js'\nimport type { SanitizedConfig } from '../config/types.js'\nimport type { PayloadRequest } from '../types/index.js'\nimport type { FileData, FileToSave, ProbedImageSize, UploadEdits } from './types.js'\n\nimport { FileRetrievalError, FileUploadError, Forbidden, MissingFile } from '../errors/index.js'\nimport { canResizeImage } from './canResizeImage.js'\nimport { cropImage } from './cropImage.js'\nimport { getExternalFile } from './getExternalFile.js'\nimport { getFileByPath } from './getFileByPath.js'\nimport { getImageSize } from './getImageSize.js'\nimport { getSafeFileName } from './getSafeFilename.js'\nimport { resizeAndTransformImageSizes } from './imageResizer.js'\nimport { isImage } from './isImage.js'\nimport { optionallyAppendMetadata } from './optionallyAppendMetadata.js'\n\ntype Args<T> = {\n  collection: Collection\n  config: SanitizedConfig\n  data: T\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc?: T\n  overwriteExistingFiles?: boolean\n  req: PayloadRequest\n  throwOnMissingFile?: boolean\n}\n\ntype Result<T> = Promise<{\n  data: T\n  files: FileToSave[]\n}>\n\nexport const generateFileData = async <T>({\n  collection: { config: collectionConfig },\n  data,\n  isDuplicating,\n  operation,\n  originalDoc,\n  overwriteExistingFiles,\n  req,\n  throwOnMissingFile,\n}: Args<T>): Result<T> => {\n  if (!collectionConfig.upload) {\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  const { sharp } = req.payload.config\n\n  let file = req.file\n\n  const uploadEdits = parseUploadEditsFromReqOrIncomingData({\n    data,\n    isDuplicating,\n    operation,\n    originalDoc,\n    req,\n  })\n\n  const {\n    disableLocalStorage,\n    focalPoint: focalPointEnabled = true,\n    formatOptions,\n    imageSizes,\n    resizeOptions,\n    staticDir,\n    trimOptions,\n    withMetadata,\n  } = collectionConfig.upload\n\n  const staticPath = staticDir\n\n  const incomingFileData = isDuplicating ? originalDoc : data\n\n  if (!file && uploadEdits && incomingFileData) {\n    const { filename, url } = incomingFileData as FileData\n\n    if (filename && (filename.includes('../') || filename.includes('..\\\\'))) {\n      throw new Forbidden(req.t)\n    }\n\n    try {\n      if (url && url.startsWith('/') && !disableLocalStorage) {\n        const filePath = `${staticPath}/${filename}`\n        const response = await getFileByPath(filePath)\n        file = response\n        overwriteExistingFiles = true\n      } else if (filename && url) {\n        file = await getExternalFile({\n          data: incomingFileData as FileData,\n          req,\n          uploadConfig: collectionConfig.upload,\n        })\n        overwriteExistingFiles = true\n      }\n    } catch (err: unknown) {\n      throw new FileRetrievalError(req.t, err instanceof Error ? err.message : undefined)\n    }\n  }\n\n  if (isDuplicating) {\n    overwriteExistingFiles = false\n  }\n\n  if (!file) {\n    if (throwOnMissingFile) {\n      throw new MissingFile(req.t)\n    }\n\n    return {\n      data,\n      files: [],\n    }\n  }\n\n  if (!disableLocalStorage) {\n    await fs.mkdir(staticPath, { recursive: true })\n  }\n\n  let newData = data\n  const filesToSave: FileToSave[] = []\n  const fileData: Partial<FileData> = {}\n  const fileIsAnimatedType = ['image/avif', 'image/gif', 'image/webp'].includes(file.mimetype)\n  const cropData =\n    typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined\n\n  try {\n    const fileSupportsResize = canResizeImage(file.mimetype)\n    let fsSafeName: string\n    let sharpFile: Sharp | undefined\n    let dimensions: ProbedImageSize | undefined\n    let fileBuffer: { data: Buffer; info: OutputInfo }\n    let ext\n    let mime: string\n    const fileHasAdjustments =\n      fileSupportsResize &&\n      Boolean(resizeOptions || formatOptions || trimOptions || file.tempFilePath)\n\n    const sharpOptions: SharpOptions = {}\n\n    if (fileIsAnimatedType) {\n      sharpOptions.animated = true\n    }\n\n    if (sharp && (fileIsAnimatedType || fileHasAdjustments)) {\n      if (file.tempFilePath) {\n        sharpFile = sharp(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      } else {\n        sharpFile = sharp(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081\n      }\n\n      if (fileHasAdjustments) {\n        if (resizeOptions) {\n          sharpFile = sharpFile.resize(resizeOptions)\n        }\n        if (formatOptions) {\n          sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options)\n        }\n        if (trimOptions) {\n          sharpFile = sharpFile.trim(trimOptions)\n        }\n      }\n    }\n\n    if (fileSupportsResize || isImage(file.mimetype)) {\n      dimensions = await getImageSize(file)\n      fileData.width = dimensions.width\n      fileData.height = dimensions.height\n    }\n\n    if (sharpFile) {\n      const metadata = await sharpFile.metadata()\n      sharpFile = await optionallyAppendMetadata({\n        req,\n        sharpFile,\n        withMetadata,\n      })\n      fileBuffer = await sharpFile.toBuffer({ resolveWithObject: true })\n      ;({ ext, mime } = await fileTypeFromBuffer(fileBuffer.data)) // This is getting an incorrect gif height back.\n      fileData.width = fileBuffer.info.width\n      fileData.height = fileBuffer.info.height\n      fileData.filesize = fileBuffer.info.size\n\n      // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages\n      if (metadata.pages) {\n        fileData.height = fileBuffer.info.height / metadata.pages\n        fileData.filesize = fileBuffer.data.length\n      }\n    } else {\n      mime = file.mimetype\n      fileData.filesize = file.size\n\n      if (file.name.includes('.')) {\n        ext = file.name.split('.').pop().split('?')[0]\n      } else {\n        ext = ''\n      }\n    }\n\n    // Adjust SVG mime type. fromBuffer modifies it.\n    if (mime === 'application/xml' && ext === 'svg') {\n      mime = 'image/svg+xml'\n    }\n    fileData.mimeType = mime\n\n    const baseFilename = sanitize(file.name.substring(0, file.name.lastIndexOf('.')) || file.name)\n    fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`\n\n    if (!overwriteExistingFiles) {\n      fsSafeName = await getSafeFileName({\n        collectionSlug: collectionConfig.slug,\n        desiredFilename: fsSafeName,\n        req,\n        staticPath,\n      })\n    }\n\n    fileData.filename = fsSafeName\n    let fileForResize = file\n\n    if (cropData && sharp) {\n      const { data: croppedImage, info } = await cropImage({\n        cropData,\n        dimensions,\n        file,\n        heightInPixels: uploadEdits.heightInPixels,\n        req,\n        sharp,\n        widthInPixels: uploadEdits.widthInPixels,\n        withMetadata,\n      })\n\n      // Apply resize after cropping to ensure it conforms to resizeOptions\n      if (resizeOptions) {\n        const resizedAfterCrop = await sharp(croppedImage)\n          .resize({\n            fit: resizeOptions?.fit || 'cover',\n            height: resizeOptions?.height,\n            position: resizeOptions?.position || 'center',\n            width: resizeOptions?.width,\n          })\n          .toBuffer({ resolveWithObject: true })\n\n        filesToSave.push({\n          buffer: resizedAfterCrop.data,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...fileForResize,\n          data: resizedAfterCrop.data,\n          size: resizedAfterCrop.info.size,\n        }\n\n        fileData.width = resizedAfterCrop.info.width\n        fileData.height = resizedAfterCrop.info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages\n            ? resizedAfterCrop.info.height / metadata.pages\n            : resizedAfterCrop.info.height\n        }\n        fileData.filesize = resizedAfterCrop.info.size\n      } else {\n        // If resizeOptions is not present, just save the cropped image\n        filesToSave.push({\n          buffer: croppedImage,\n          path: `${staticPath}/${fsSafeName}`,\n        })\n\n        fileForResize = {\n          ...file,\n          data: croppedImage,\n          size: info.size,\n        }\n\n        fileData.width = info.width\n        fileData.height = info.height\n        if (fileIsAnimatedType) {\n          const metadata = await sharpFile.metadata()\n          fileData.height = metadata.pages ? info.height / metadata.pages : info.height\n        }\n        fileData.filesize = info.size\n      }\n\n      if (file.tempFilePath) {\n        await fs.writeFile(file.tempFilePath, croppedImage) // write fileBuffer to the temp path\n      } else {\n        req.file = fileForResize\n      }\n    } else {\n      filesToSave.push({\n        buffer: fileBuffer?.data || file.data,\n        path: `${staticPath}/${fsSafeName}`,\n      })\n\n      // If using temp files and the image is being resized, write the file to the temp path\n      if (fileBuffer?.data || file.data.length > 0) {\n        if (file.tempFilePath) {\n          await fs.writeFile(file.tempFilePath, fileBuffer?.data || file.data) // write fileBuffer to the temp path\n        } else {\n          // Assign the _possibly modified_ file to the request object\n          req.file = {\n            ...file,\n            data: fileBuffer?.data || file.data,\n            size: fileBuffer?.info.size,\n          }\n        }\n      }\n    }\n\n    if (fileSupportsResize && (Array.isArray(imageSizes) || focalPointEnabled !== false)) {\n      req.payloadUploadSizes = {}\n      const { focalPoint, sizeData, sizesToSave } = await resizeAndTransformImageSizes({\n        config: collectionConfig,\n        dimensions: !cropData\n          ? dimensions\n          : {\n              ...dimensions,\n              height: fileData.height,\n              width: fileData.width,\n            },\n        file: fileForResize,\n        mimeType: fileData.mimeType,\n        req,\n        savedFilename: fsSafeName || file.name,\n        sharp,\n        staticPath,\n        uploadEdits,\n        withMetadata,\n      })\n\n      fileData.sizes = sizeData\n      fileData.focalX = focalPoint?.x\n      fileData.focalY = focalPoint?.y\n      filesToSave.push(...sizesToSave)\n    }\n  } catch (err) {\n    req.payload.logger.error(err)\n    throw new FileUploadError(req.t)\n  }\n\n  newData = {\n    ...newData,\n    ...fileData,\n  }\n\n  return {\n    data: newData,\n    files: filesToSave,\n  }\n}\n\n/**\n * Parse upload edits from req or incoming data\n */\nfunction parseUploadEditsFromReqOrIncomingData(args: {\n  data: unknown\n  isDuplicating?: boolean\n  operation: 'create' | 'update'\n  originalDoc: unknown\n  req: PayloadRequest\n}): UploadEdits {\n  const { data, isDuplicating, operation, originalDoc, req } = args\n\n  // Get intended focal point change from query string or incoming data\n  const uploadEdits =\n    req.query?.uploadEdits && typeof req.query.uploadEdits === 'object'\n      ? (req.query.uploadEdits as UploadEdits)\n      : {}\n\n  if (uploadEdits.focalPoint) {\n    return uploadEdits\n  }\n\n  const incomingData = data as FileData\n  const origDoc = originalDoc as FileData\n\n  if (origDoc && 'focalX' in origDoc && 'focalY' in origDoc) {\n    // If no change in focal point, return undefined.\n    // This prevents a refocal operation triggered from admin, because it always sends the focal point.\n    if (incomingData.focalX === origDoc.focalX && incomingData.focalY === origDoc.focalY) {\n      return undefined\n    }\n\n    if (isDuplicating) {\n      uploadEdits.focalPoint = {\n        x: incomingData?.focalX || origDoc.focalX,\n        y: incomingData?.focalY || origDoc.focalX,\n      }\n    }\n  }\n\n  if (incomingData?.focalX && incomingData?.focalY) {\n    uploadEdits.focalPoint = {\n      x: incomingData.focalX,\n      y: incomingData.focalY,\n    }\n    return uploadEdits\n  }\n\n  // If no focal point is set, default to center\n  if (operation === 'create') {\n    uploadEdits.focalPoint = {\n      x: 50,\n      y: 50,\n    }\n  }\n\n  return uploadEdits\n}\n"],"names":["fileTypeFromBuffer","fs","sanitize","FileRetrievalError","FileUploadError","Forbidden","MissingFile","canResizeImage","cropImage","getExternalFile","getFileByPath","getImageSize","getSafeFileName","resizeAndTransformImageSizes","isImage","optionallyAppendMetadata","generateFileData","collection","config","collectionConfig","data","isDuplicating","operation","originalDoc","overwriteExistingFiles","req","throwOnMissingFile","upload","files","sharp","payload","file","uploadEdits","parseUploadEditsFromReqOrIncomingData","disableLocalStorage","focalPoint","focalPointEnabled","formatOptions","imageSizes","resizeOptions","staticDir","trimOptions","withMetadata","staticPath","incomingFileData","filename","url","includes","t","startsWith","filePath","response","uploadConfig","err","Error","message","undefined","mkdir","recursive","newData","filesToSave","fileData","fileIsAnimatedType","mimetype","cropData","crop","fileSupportsResize","fsSafeName","sharpFile","dimensions","fileBuffer","ext","mime","fileHasAdjustments","Boolean","tempFilePath","sharpOptions","animated","rotate","resize","toFormat","format","options","trim","width","height","metadata","toBuffer","resolveWithObject","info","filesize","size","pages","length","name","split","pop","mimeType","baseFilename","substring","lastIndexOf","collectionSlug","slug","desiredFilename","fileForResize","croppedImage","heightInPixels","widthInPixels","resizedAfterCrop","fit","position","push","buffer","path","writeFile","Array","isArray","payloadUploadSizes","sizeData","sizesToSave","savedFilename","sizes","focalX","x","focalY","y","logger","error","args","query","incomingData","origDoc"],"mappings":"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"}