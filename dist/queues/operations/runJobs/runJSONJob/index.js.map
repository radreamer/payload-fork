{"version":3,"sources":["../../../../../src/queues/operations/runJobs/runJSONJob/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type { WorkflowJSON, WorkflowStep } from '../../../config/types/workflowJSONTypes.js'\nimport type {\n  BaseJob,\n  RunningJob,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from '../runJob/getUpdateJobFunction.js'\nimport type { JobRunStatus } from '../runJob/index.js'\n\nimport { getRunTaskFunction, type RunTaskFunctionState } from '../runJob/getRunTaskFunction.js'\nimport { handleWorkflowError } from '../runJob/handleWorkflowError.js'\n\ntype Args = {\n  job: BaseJob\n  req: PayloadRequest\n  updateJob: UpdateJobFunction\n  workflowConfig: WorkflowConfig<WorkflowTypes>\n  workflowHandler: WorkflowJSON<WorkflowTypes>\n}\n\nexport type RunJSONJobResult = {\n  status: JobRunStatus\n}\n\nexport const runJSONJob = async ({\n  job,\n  req,\n  updateJob,\n  workflowConfig,\n  workflowHandler,\n}: Args): Promise<RunJSONJobResult> => {\n  // Object so that we can pass contents by reference, not value.\n  // We want any mutations to be reflected in here.\n  const state: RunTaskFunctionState = {\n    reachedMaxRetries: false,\n  }\n\n  const stepsToRun: WorkflowStep<string, string>[] = []\n\n  for (const step of workflowHandler) {\n    if ('task' in step) {\n      if (job?.taskStatus?.[step.task]?.[step.id]?.complete) {\n        continue\n      }\n    } else {\n      if (job?.taskStatus?.['inline']?.[step.id]?.complete) {\n        continue\n      }\n    }\n    if (step.condition && !step.condition({ job: job as RunningJob<any> })) {\n      // TODO: Improve RunningJob type see todo below\n      continue\n    }\n    stepsToRun.push(step)\n  }\n\n  const tasks = getRunTaskFunction(state, job, workflowConfig, req, false, updateJob)\n  const inlineTask = getRunTaskFunction(state, job, workflowConfig, req, true, updateJob)\n\n  // Run the job\n  let hasFinalError = false\n  let error: Error | undefined\n  try {\n    await Promise.all(\n      stepsToRun.map(async (step) => {\n        if ('task' in step) {\n          await tasks[step.task](step.id, {\n            input: step.input ? step.input({ job: job as RunningJob<any> }) : {}, // TODO: Type better. We should use RunningJob anywhere and make TypedCollection['payload-jobs'] be BaseJob if type not generated\n            retries: step.retries,\n          })\n        } else {\n          await inlineTask(step.id, {\n            retries: step.retries,\n            task: step.inlineTask as any, // TODO: Fix type\n          })\n        }\n      }),\n    )\n  } catch (err) {\n    const errorResult = handleWorkflowError({\n      error: err,\n      job,\n      req,\n      state,\n      workflowConfig,\n    })\n    error = err\n    hasFinalError = errorResult.hasFinalError\n  }\n\n  // Check if workflow has completed\n  let workflowCompleted = false\n  for (const [slug, map] of Object.entries(job.taskStatus)) {\n    for (const [id, taskStatus] of Object.entries(map)) {\n      if (taskStatus.complete) {\n        const step = workflowHandler.find((step) => {\n          if ('task' in step) {\n            return step.task === slug && step.id === id\n          } else {\n            return step.id === id && slug === 'inline'\n          }\n        })\n        if (step.completesJob) {\n          workflowCompleted = true\n          break\n        }\n      }\n    }\n  }\n\n  if (workflowCompleted) {\n    if (error) {\n      // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n      // we need to ensure the job is updated to reflect the error\n      await updateJob({\n        completedAt: new Date().toISOString(),\n        error: hasFinalError ? error : undefined,\n        hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n        processing: false,\n        totalTried: (job.totalTried ?? 0) + 1,\n      })\n    } else {\n      await updateJob({\n        completedAt: new Date().toISOString(),\n        processing: false,\n        totalTried: (job.totalTried ?? 0) + 1,\n      })\n    }\n\n    return {\n      status: 'success',\n    }\n  } else {\n    if (error) {\n      // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n      // we need to ensure the job is updated to reflect the error\n      await updateJob({\n        error: hasFinalError ? error : undefined,\n        hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n        processing: false,\n        totalTried: (job.totalTried ?? 0) + 1,\n      })\n      return {\n        status: hasFinalError ? 'error-reached-max-retries' : 'error',\n      }\n    } else {\n      // Retry the job - no need to bump processing or totalTried as this does not count as a retry. A condition of a different task might have just opened up!\n      return await runJSONJob({\n        job,\n        req,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n    }\n  }\n}\n"],"names":["getRunTaskFunction","handleWorkflowError","runJSONJob","job","req","updateJob","workflowConfig","workflowHandler","state","reachedMaxRetries","stepsToRun","step","taskStatus","task","id","complete","condition","push","tasks","inlineTask","hasFinalError","error","Promise","all","map","input","retries","err","errorResult","workflowCompleted","slug","Object","entries","find","completesJob","completedAt","Date","toISOString","undefined","hasError","processing","totalTried","status"],"mappings":"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"}