{"version":3,"sources":["../../../../../src/queues/operations/runJobs/runJob/getRunTaskFunction.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\n// @ts-strict-ignore\nimport type { PayloadRequest } from '../../../../types/index.js'\nimport type {\n  RetryConfig,\n  RunInlineTaskFunction,\n  RunTaskFunction,\n  RunTaskFunctions,\n  TaskConfig,\n  TaskHandler,\n  TaskHandlerResult,\n  TaskType,\n} from '../../../config/types/taskTypes.js'\nimport type {\n  BaseJob,\n  RunningJob,\n  SingleTaskStatus,\n  WorkflowConfig,\n  WorkflowTypes,\n} from '../../../config/types/workflowTypes.js'\nimport type { UpdateJobFunction } from './getUpdateJobFunction.js'\n\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { importHandlerPath } from './importHandlerPath.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\n// Helper object type to force being passed by reference\nexport type RunTaskFunctionState = {\n  reachedMaxRetries: boolean\n}\n\nasync function getTaskHandlerFromConfig(taskConfig: TaskConfig<string>) {\n  let handler: TaskHandler<TaskType>\n\n  if (typeof taskConfig.handler === 'function') {\n    handler = taskConfig.handler\n  } else {\n    handler = await importHandlerPath<TaskHandler<TaskType>>(taskConfig.handler)\n  }\n  return handler\n}\n\nexport async function handleTaskFailed({\n  error,\n  executedAt,\n  input,\n  job,\n  maxRetries,\n  output,\n  parent,\n  req,\n  retriesConfig,\n  state,\n  taskConfig,\n  taskHandlerResult,\n  taskID,\n  taskSlug,\n  taskStatus,\n  updateJob,\n}: {\n  error?: Error\n  executedAt: Date\n  input: object\n  job: BaseJob\n  maxRetries: number\n  output: object\n  parent?: TaskParent\n  req: PayloadRequest\n  retriesConfig: number | RetryConfig\n  state: RunTaskFunctionState\n  taskConfig?: TaskConfig<string>\n  taskHandlerResult?: TaskHandlerResult<string>\n  taskID: string\n  taskSlug: string\n  taskStatus: null | SingleTaskStatus<string>\n  updateJob: UpdateJobFunction\n}): Promise<never> {\n  req.payload.logger.error({ err: error, job, msg: `Error running task ${taskID}`, taskSlug })\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail()\n  }\n\n  if (!job.log) {\n    job.log = []\n  }\n  const errorJSON = error\n    ? {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n      }\n    : {\n        message:\n          taskHandlerResult.state === 'failed'\n            ? (taskHandlerResult.errorMessage ?? taskHandlerResult.state)\n            : 'failed',\n      }\n\n  job.log.push({\n    id: new ObjectId().toHexString(),\n    completedAt: new Date().toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output,\n    parent: req?.payload?.config?.jobs?.addParentToTaskLog ? parent : undefined,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  })\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < new Date()) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    state.reachedMaxRetries = true\n\n    await updateJob({\n      error,\n      hasError: true,\n      log: job.log,\n      processing: false,\n      waitUntil: job.waitUntil,\n    })\n\n    throw new Error(\n      `Task ${taskSlug} has failed more than the allowed retries in workflow ${job.workflowSlug}${error ? `. Error: ${String(error)}` : ''}`,\n    )\n  } else {\n    // Job will retry. Let's determine when!\n    const waitUntil: Date = calculateBackoffWaitUntil({\n      retriesConfig,\n      totalTried: taskStatus?.totalTried ?? 0,\n    })\n\n    // Update job's waitUntil only if this waitUntil is later than the current one\n    if (!job.waitUntil || waitUntil > new Date(job.waitUntil)) {\n      job.waitUntil = waitUntil.toISOString()\n    }\n\n    await updateJob({\n      log: job.log,\n      processing: false,\n      waitUntil: job.waitUntil,\n    })\n    throw error ?? new Error('Task failed')\n  }\n}\n\nexport type TaskParent = {\n  taskID: string\n  taskSlug: string\n}\n\nexport const getRunTaskFunction = <TIsInline extends boolean>(\n  state: RunTaskFunctionState,\n  job: BaseJob,\n  workflowConfig: WorkflowConfig<string>,\n  req: PayloadRequest,\n  isInline: TIsInline,\n  updateJob: UpdateJobFunction,\n  parent?: TaskParent,\n): TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions => {\n  const runTask: <TTaskSlug extends string>(\n    taskSlug: TTaskSlug,\n  ) => TTaskSlug extends 'inline' ? RunInlineTaskFunction : RunTaskFunction<TTaskSlug> = (\n    taskSlug,\n  ) =>\n    (async (\n      taskID: Parameters<RunInlineTaskFunction>[0],\n      {\n        input,\n        retries,\n        task,\n      }: Parameters<RunInlineTaskFunction>[1] & Parameters<RunTaskFunction<string>>[1],\n    ) => {\n      const executedAt = new Date()\n\n      let inlineRunner: TaskHandler<TaskType> = null\n      if (isInline) {\n        inlineRunner = task\n      }\n\n      let taskConfig: TaskConfig<string>\n      if (!isInline) {\n        taskConfig =\n          req.payload.config.jobs.tasks?.length &&\n          req.payload.config.jobs.tasks.find((t) => t.slug === taskSlug)\n\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n      }\n\n      const retriesConfigFromPropsNormalized =\n        retries == undefined || retries == null\n          ? {}\n          : typeof retries === 'number'\n            ? { attempts: retries }\n            : retries\n      const retriesConfigFromTaskConfigNormalized = taskConfig\n        ? typeof taskConfig.retries === 'number'\n          ? { attempts: taskConfig.retries }\n          : taskConfig.retries\n        : {}\n\n      const finalRetriesConfig: RetryConfig = {\n        ...retriesConfigFromTaskConfigNormalized,\n        ...retriesConfigFromPropsNormalized, // Retry config from props takes precedence\n      }\n\n      const taskStatus: null | SingleTaskStatus<string> = job?.taskStatus?.[taskSlug]\n        ? job.taskStatus[taskSlug][taskID]\n        : null\n\n      // Handle restoration of task if it succeeded in a previous run\n      if (taskStatus && taskStatus.complete === true) {\n        let shouldRestore = true\n        if (finalRetriesConfig?.shouldRestore === false) {\n          shouldRestore = false\n        } else if (typeof finalRetriesConfig?.shouldRestore === 'function') {\n          shouldRestore = await finalRetriesConfig.shouldRestore({ input, job, req, taskStatus })\n        }\n        if (shouldRestore) {\n          return taskStatus.output\n        }\n      }\n\n      let runner: TaskHandler<TaskType>\n      if (isInline) {\n        runner = inlineRunner\n      } else {\n        if (!taskConfig) {\n          throw new Error(`Task ${taskSlug} not found in workflow ${job.workflowSlug}`)\n        }\n        runner = await getTaskHandlerFromConfig(taskConfig)\n      }\n\n      if (!runner || typeof runner !== 'function') {\n        const errorMessage = isInline\n          ? `Can't find runner for inline task with ID ${taskID}`\n          : `Can't find runner while importing with the path ${typeof workflowConfig.handler === 'string' ? workflowConfig.handler : 'unknown - no string path'} in job type ${job.workflowSlug} for task ${taskSlug}.`\n        req.payload.logger.error(errorMessage)\n\n        await updateJob({\n          error: {\n            error: errorMessage,\n          },\n          hasError: true,\n          log: [\n            ...job.log,\n            {\n              id: new ObjectId().toHexString(),\n              completedAt: new Date().toISOString(),\n              error: errorMessage,\n              executedAt: executedAt.toISOString(),\n              parent: req?.payload?.config?.jobs?.addParentToTaskLog ? parent : undefined,\n              state: 'failed',\n              taskID,\n              taskSlug,\n            },\n          ],\n          processing: false,\n        })\n\n        throw new Error(errorMessage)\n      }\n\n      let maxRetries: number | undefined = finalRetriesConfig?.attempts\n\n      if (maxRetries === undefined || maxRetries === null) {\n        // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n        if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n          maxRetries =\n            typeof workflowConfig.retries === 'object'\n              ? workflowConfig.retries.attempts\n              : workflowConfig.retries\n        } else {\n          maxRetries = 0\n        }\n      }\n\n      let taskHandlerResult: TaskHandlerResult<string>\n      let output: object = {}\n\n      try {\n        taskHandlerResult = await runner({\n          inlineTask: getRunTaskFunction(state, job, workflowConfig, req, true, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n          input,\n          job: job as unknown as RunningJob<WorkflowTypes>, // TODO: Type this better\n          req,\n          tasks: getRunTaskFunction(state, job, workflowConfig, req, false, updateJob, {\n            taskID,\n            taskSlug,\n          }),\n        })\n      } catch (err) {\n        await handleTaskFailed({\n          error: err,\n          executedAt,\n          input,\n          job,\n          maxRetries,\n          output,\n          parent,\n          req,\n          retriesConfig: finalRetriesConfig,\n          state,\n          taskConfig,\n          taskID,\n          taskSlug,\n          taskStatus,\n          updateJob,\n        })\n        throw new Error('Task failed')\n      }\n\n      if (taskHandlerResult.state === 'failed') {\n        await handleTaskFailed({\n          executedAt,\n          input,\n          job,\n          maxRetries,\n          output,\n          parent,\n          req,\n          retriesConfig: finalRetriesConfig,\n          state,\n          taskConfig,\n          taskHandlerResult,\n          taskID,\n          taskSlug,\n          taskStatus,\n          updateJob,\n        })\n        throw new Error('Task failed')\n      } else {\n        output = taskHandlerResult.output\n      }\n\n      if (taskConfig?.onSuccess) {\n        await taskConfig.onSuccess()\n      }\n\n      if (!job.log) {\n        job.log = []\n      }\n      job.log.push({\n        id: new ObjectId().toHexString(),\n        completedAt: new Date().toISOString(),\n        executedAt: executedAt.toISOString(),\n        input,\n        output,\n        parent: req?.payload?.config?.jobs?.addParentToTaskLog ? parent : undefined,\n        state: 'succeeded',\n        taskID,\n        taskSlug,\n      })\n\n      await updateJob({\n        log: job.log,\n      })\n\n      return output\n    }) as any\n\n  if (isInline) {\n    return runTask('inline') as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  } else {\n    const tasks: RunTaskFunctions = {}\n    for (const task of req?.payload?.config?.jobs?.tasks ?? []) {\n      tasks[task.slug] = runTask(task.slug)\n    }\n    return tasks as TIsInline extends true ? RunInlineTaskFunction : RunTaskFunctions\n  }\n}\n"],"names":["ObjectIdImport","calculateBackoffWaitUntil","importHandlerPath","ObjectId","default","getTaskHandlerFromConfig","taskConfig","handler","handleTaskFailed","error","executedAt","input","job","maxRetries","output","parent","req","retriesConfig","state","taskHandlerResult","taskID","taskSlug","taskStatus","updateJob","payload","logger","err","msg","onFail","log","errorJSON","name","message","stack","errorMessage","push","id","toHexString","completedAt","Date","toISOString","config","jobs","addParentToTaskLog","undefined","waitUntil","complete","totalTried","reachedMaxRetries","hasError","processing","Error","workflowSlug","String","getRunTaskFunction","workflowConfig","isInline","runTask","retries","task","inlineRunner","tasks","length","find","t","slug","retriesConfigFromPropsNormalized","attempts","retriesConfigFromTaskConfigNormalized","finalRetriesConfig","shouldRestore","runner","inlineTask","onSuccess"],"mappings":"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"}