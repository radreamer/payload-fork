{"version":3,"sources":["../../../../src/queues/operations/runJobs/index.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { PayloadRequest, Sort, Where } from '../../../types/index.js'\nimport type { WorkflowJSON } from '../../config/types/workflowJSONTypes.js'\nimport type {\n  BaseJob,\n  WorkflowConfig,\n  WorkflowHandler,\n  WorkflowTypes,\n} from '../../config/types/workflowTypes.js'\nimport type { RunJobResult } from './runJob/index.js'\n\nimport { Forbidden } from '../../../errors/Forbidden.js'\nimport isolateObjectProperty from '../../../utilities/isolateObjectProperty.js'\nimport { jobsCollectionSlug } from '../../config/index.js'\nimport { updateJob, updateJobs } from '../../utilities/updateJob.js'\nimport { getUpdateJobFunction } from './runJob/getUpdateJobFunction.js'\nimport { importHandlerPath } from './runJob/importHandlerPath.js'\nimport { runJob } from './runJob/index.js'\nimport { runJSONJob } from './runJSONJob/index.js'\n\nexport type RunJobsArgs = {\n  /**\n   * ID of the job to run\n   */\n  id?: number | string\n  limit?: number\n  overrideAccess?: boolean\n  /**\n   * Adjust the job processing order\n   *\n   * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n   *\n   * @default all jobs for all queues will be executed in FIFO order.\n   */\n  processingOrder?: Sort\n  queue?: string\n  req: PayloadRequest\n  /**\n   * By default, jobs are run in parallel.\n   * If you want to run them in sequence, set this to true.\n   */\n  sequential?: boolean\n  where?: Where\n}\n\nexport type RunJobsResult = {\n  jobStatus?: Record<string, RunJobResult>\n  /**\n   * If this is false, there for sure are no jobs remaining, regardless of the limit\n   */\n  noJobsRemaining?: boolean\n  /**\n   * Out of the jobs that were queried & processed (within the set limit), how many are remaining and retryable?\n   */\n  remainingJobsFromQueried: number\n}\n\nexport const runJobs = async (args: RunJobsArgs): Promise<RunJobsResult> => {\n  const {\n    id,\n    limit = 10,\n    overrideAccess,\n    processingOrder,\n    queue,\n    req,\n    sequential,\n    where: whereFromProps,\n  } = args\n\n  if (!overrideAccess) {\n    const hasAccess = await req.payload.config.jobs.access.run({ req })\n    if (!hasAccess) {\n      throw new Forbidden(req.t)\n    }\n  }\n  const where: Where = {\n    and: [\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n      {\n        processing: {\n          equals: false,\n        },\n      },\n      {\n        or: [\n          {\n            waitUntil: {\n              exists: false,\n            },\n          },\n          {\n            waitUntil: {\n              less_than: new Date().toISOString(),\n            },\n          },\n        ],\n      },\n    ],\n  }\n\n  if (queue) {\n    where.and.push({\n      queue: {\n        equals: queue,\n      },\n    })\n  }\n\n  if (whereFromProps) {\n    where.and.push(whereFromProps)\n  }\n\n  // Find all jobs and ensure we set job to processing: true as early as possible to reduce the chance of\n  // the same job being picked up by another worker\n  const jobsQuery: {\n    docs: BaseJob[]\n  } = { docs: [] }\n\n  if (id) {\n    // Only one job to run\n    jobsQuery.docs = [\n      await updateJob({\n        id,\n        data: {\n          processing: true,\n        },\n        depth: req.payload.config.jobs.depth,\n        disableTransaction: true,\n        req,\n        returning: true,\n      }),\n    ]\n  } else {\n    let defaultProcessingOrder: Sort =\n      req.payload.collections[jobsCollectionSlug].config.defaultSort ?? 'createdAt'\n\n    const processingOrderConfig = req.payload.config.jobs?.processingOrder\n    if (typeof processingOrderConfig === 'function') {\n      defaultProcessingOrder = await processingOrderConfig(args)\n    } else if (typeof processingOrderConfig === 'object' && !Array.isArray(processingOrderConfig)) {\n      if (queue && processingOrderConfig.queues && processingOrderConfig.queues[queue]) {\n        defaultProcessingOrder = processingOrderConfig.queues[queue]\n      } else if (processingOrderConfig.default) {\n        defaultProcessingOrder = processingOrderConfig.default\n      }\n    } else if (typeof processingOrderConfig === 'string') {\n      defaultProcessingOrder = processingOrderConfig\n    }\n    const updatedDocs = await updateJobs({\n      data: {\n        processing: true,\n      },\n      depth: req.payload.config.jobs.depth,\n      disableTransaction: true,\n      limit,\n      req,\n      returning: true,\n      sort: processingOrder ?? defaultProcessingOrder,\n      where,\n    })\n\n    if (updatedDocs) {\n      jobsQuery.docs = updatedDocs\n    }\n  }\n\n  /**\n   * Just for logging purposes, we want to know how many jobs are new and how many are existing (= already been tried).\n   * This is only for logs - in the end we still want to run all jobs, regardless of whether they are new or existing.\n   */\n  const { existingJobs, newJobs } = jobsQuery.docs.reduce(\n    (acc, job) => {\n      if (job.totalTried > 0) {\n        acc.existingJobs.push(job)\n      } else {\n        acc.newJobs.push(job)\n      }\n      return acc\n    },\n    { existingJobs: [], newJobs: [] },\n  )\n\n  if (!jobsQuery.docs.length) {\n    return {\n      noJobsRemaining: true,\n      remainingJobsFromQueried: 0,\n    }\n  }\n\n  if (jobsQuery?.docs?.length) {\n    req.payload.logger.info({\n      msg: `Running ${jobsQuery.docs.length} jobs.`,\n      new: newJobs?.length,\n      retrying: existingJobs?.length,\n    })\n  }\n  const jobsToDelete: (number | string)[] | undefined = req.payload.config.jobs.deleteJobOnComplete\n    ? []\n    : undefined\n\n  const runSingleJob = async (job) => {\n    if (!job.workflowSlug && !job.taskSlug) {\n      throw new Error('Job must have either a workflowSlug or a taskSlug')\n    }\n    const jobReq = isolateObjectProperty(req, 'transactionID')\n\n    const workflowConfig: WorkflowConfig<WorkflowTypes> = job.workflowSlug\n      ? req.payload.config.jobs?.workflows.find(({ slug }) => slug === job.workflowSlug)\n      : {\n          slug: 'singleTask',\n          handler: async ({ job, tasks }) => {\n            await tasks[job.taskSlug as string]('1', {\n              input: job.input,\n            })\n          },\n        }\n\n    if (!workflowConfig) {\n      return null // Skip jobs with no workflow configuration\n    }\n\n    const updateJob = getUpdateJobFunction(job, jobReq)\n\n    // the runner will either be passed to the config\n    // OR it will be a path, which we will need to import via eval to avoid\n    // Next.js compiler dynamic import expression errors\n    let workflowHandler: WorkflowHandler<WorkflowTypes> | WorkflowJSON<WorkflowTypes>\n\n    if (\n      typeof workflowConfig.handler === 'function' ||\n      (typeof workflowConfig.handler === 'object' && Array.isArray(workflowConfig.handler))\n    ) {\n      workflowHandler = workflowConfig.handler\n    } else {\n      workflowHandler = await importHandlerPath<typeof workflowHandler>(workflowConfig.handler)\n\n      if (!workflowHandler) {\n        const jobLabel = job.workflowSlug || `Task: ${job.taskSlug}`\n        const errorMessage = `Can't find runner while importing with the path ${workflowConfig.handler} in job type ${jobLabel}.`\n        req.payload.logger.error(errorMessage)\n\n        await updateJob({\n          error: {\n            error: errorMessage,\n          },\n          hasError: true,\n          processing: false,\n        })\n\n        return\n      }\n    }\n\n    if (typeof workflowHandler === 'function') {\n      const result = await runJob({\n        job,\n        req: jobReq,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n\n      if (result.status !== 'error' && jobsToDelete) {\n        jobsToDelete.push(job.id)\n      }\n\n      return { id: job.id, result }\n    } else {\n      const result = await runJSONJob({\n        job,\n        req: jobReq,\n        updateJob,\n        workflowConfig,\n        workflowHandler,\n      })\n\n      if (result.status !== 'error' && jobsToDelete) {\n        jobsToDelete.push(job.id)\n      }\n\n      return { id: job.id, result }\n    }\n  }\n\n  let resultsArray: { id: number | string; result: RunJobResult }[] = []\n  if (sequential) {\n    for (const job of jobsQuery.docs) {\n      const result = await runSingleJob(job)\n      if (result !== null) {\n        resultsArray.push(result)\n      }\n    }\n  } else {\n    const jobPromises = jobsQuery.docs.map(runSingleJob)\n    resultsArray = await Promise.all(jobPromises)\n  }\n\n  if (jobsToDelete && jobsToDelete.length > 0) {\n    try {\n      if (req.payload.config.jobs.runHooks) {\n        await req.payload.delete({\n          collection: jobsCollectionSlug,\n          depth: 0, // can be 0 since we're not returning anything\n          disableTransaction: true,\n          where: { id: { in: jobsToDelete } },\n        })\n      } else {\n        await req.payload.db.deleteMany({\n          collection: jobsCollectionSlug,\n          where: { id: { in: jobsToDelete } },\n        })\n      }\n    } catch (err) {\n      req.payload.logger.error({\n        err,\n        msg: `failed to delete jobs ${jobsToDelete.join(', ')} on complete`,\n      })\n    }\n  }\n\n  const resultsObject: RunJobsResult['jobStatus'] = resultsArray.reduce((acc, cur) => {\n    if (cur !== null) {\n      // Check if there's a valid result to include\n      acc[cur.id] = cur.result\n    }\n    return acc\n  }, {})\n\n  let remainingJobsFromQueried = 0\n  for (const jobID in resultsObject) {\n    const jobResult = resultsObject[jobID]\n    if (jobResult.status === 'error') {\n      remainingJobsFromQueried++ // Can be retried\n    }\n  }\n\n  return {\n    jobStatus: resultsObject,\n    remainingJobsFromQueried,\n  }\n}\n"],"names":["Forbidden","isolateObjectProperty","jobsCollectionSlug","updateJob","updateJobs","getUpdateJobFunction","importHandlerPath","runJob","runJSONJob","runJobs","args","id","limit","overrideAccess","processingOrder","queue","req","sequential","where","whereFromProps","hasAccess","payload","config","jobs","access","run","t","and","completedAt","exists","hasError","not_equals","processing","equals","or","waitUntil","less_than","Date","toISOString","push","jobsQuery","docs","data","depth","disableTransaction","returning","defaultProcessingOrder","collections","defaultSort","processingOrderConfig","Array","isArray","queues","default","updatedDocs","sort","existingJobs","newJobs","reduce","acc","job","totalTried","length","noJobsRemaining","remainingJobsFromQueried","logger","info","msg","new","retrying","jobsToDelete","deleteJobOnComplete","undefined","runSingleJob","workflowSlug","taskSlug","Error","jobReq","workflowConfig","workflows","find","slug","handler","tasks","input","workflowHandler","jobLabel","errorMessage","error","result","status","resultsArray","jobPromises","map","Promise","all","runHooks","delete","collection","in","db","deleteMany","err","join","resultsObject","cur","jobID","jobResult","jobStatus"],"mappings":"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"}