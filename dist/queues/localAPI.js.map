{"version":3,"sources":["../../src/queues/localAPI.ts"],"sourcesContent":["import type { BaseJob, RunningJobFromTask } from './config/types/workflowTypes.js'\n\nimport {\n  createLocalReq,\n  type Payload,\n  type PayloadRequest,\n  type RunningJob,\n  type Sort,\n  type TypedJobs,\n  type Where,\n} from '../index.js'\nimport { jobAfterRead, jobsCollectionSlug } from './config/index.js'\nimport { runJobs } from './operations/runJobs/index.js'\nimport { updateJob, updateJobs } from './utilities/updateJob.js'\n\nexport const getJobsLocalAPI = (payload: Payload) => ({\n  queue: async <\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] | keyof TypedJobs['workflows'],\n  >(\n    args:\n      | {\n          input: TypedJobs['tasks'][TTaskOrWorkflowSlug]['input']\n          queue?: string\n          req?: PayloadRequest\n          // TTaskOrWorkflowlug with keyof TypedJobs['workflows'] removed:\n          task: TTaskOrWorkflowSlug extends keyof TypedJobs['tasks'] ? TTaskOrWorkflowSlug : never\n          waitUntil?: Date\n          workflow?: never\n        }\n      | {\n          input: TypedJobs['workflows'][TTaskOrWorkflowSlug]['input']\n          queue?: string\n          req?: PayloadRequest\n          task?: never\n          waitUntil?: Date\n          workflow: TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n            ? TTaskOrWorkflowSlug\n            : never\n        },\n  ): Promise<\n    TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? RunningJob<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug>\n  > => {\n    let queue: string | undefined = undefined\n\n    // If user specifies queue, use that\n    if (args.queue) {\n      queue = args.queue\n    } else if (args.workflow) {\n      // Otherwise, if there is a workflow specified, and it has a default queue to use,\n      // use that\n      const workflow = payload.config.jobs?.workflows?.find(({ slug }) => slug === args.workflow)\n      if (workflow?.queue) {\n        queue = workflow.queue\n      }\n    }\n\n    const data: Partial<BaseJob> = {\n      input: args.input,\n    }\n\n    if (queue) {\n      data.queue = queue\n    }\n    if (args.waitUntil) {\n      data.waitUntil = args.waitUntil?.toISOString()\n    }\n    if (args.workflow) {\n      data.workflowSlug = args.workflow as string\n    }\n    if (args.task) {\n      data.taskSlug = args.task as string\n    }\n\n    type ReturnType = TTaskOrWorkflowSlug extends keyof TypedJobs['workflows']\n      ? RunningJob<TTaskOrWorkflowSlug>\n      : RunningJobFromTask<TTaskOrWorkflowSlug> // Type assertion is still needed here\n\n    if (payload?.config?.jobs?.depth || payload?.config?.jobs?.runHooks) {\n      return (await payload.create({\n        collection: jobsCollectionSlug,\n        data,\n        depth: payload.config.jobs.depth ?? 0,\n        req: args.req,\n      })) as ReturnType\n    } else {\n      return jobAfterRead({\n        config: payload.config,\n        doc: await payload.db.create({\n          collection: jobsCollectionSlug,\n          data,\n          req: args.req,\n        }),\n      }) as unknown as ReturnType\n    }\n  },\n\n  run: async (args?: {\n    limit?: number\n    overrideAccess?: boolean\n    /**\n     * Adjust the job processing order using a Payload sort string.\n     *\n     * FIFO would equal `createdAt` and LIFO would equal `-createdAt`.\n     */\n    processingOrder?: Sort\n    queue?: string\n    req?: PayloadRequest\n    /**\n     * By default, jobs are run in parallel.\n     * If you want to run them in sequence, set this to true.\n     */\n    sequential?: boolean\n    where?: Where\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args?.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      limit: args?.limit,\n      overrideAccess: args?.overrideAccess !== false,\n      processingOrder: args?.processingOrder,\n      queue: args?.queue,\n      req: newReq,\n      sequential: args?.sequential,\n      where: args?.where,\n    })\n  },\n\n  runByID: async (args: {\n    id: number | string\n    overrideAccess?: boolean\n    req?: PayloadRequest\n  }): Promise<ReturnType<typeof runJobs>> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    return await runJobs({\n      id: args.id,\n      overrideAccess: args.overrideAccess !== false,\n      req: newReq,\n    })\n  },\n\n  cancel: async (args: {\n    overrideAccess?: boolean\n    queue?: string\n    req?: PayloadRequest\n    where: Where\n  }): Promise<void> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    const and: Where[] = [\n      args.where,\n      {\n        completedAt: {\n          exists: false,\n        },\n      },\n      {\n        hasError: {\n          not_equals: true,\n        },\n      },\n    ]\n\n    if (args.queue) {\n      and.push({\n        queue: {\n          equals: args.queue,\n        },\n      })\n    }\n\n    await updateJobs({\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      } as {\n        completedAt: null\n        waitUntil: null\n      } & BaseJob,\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req: newReq,\n      returning: false,\n      where: { and },\n    })\n  },\n\n  cancelByID: async (args: {\n    id: number | string\n    overrideAccess?: boolean\n    req?: PayloadRequest\n  }): Promise<void> => {\n    const newReq: PayloadRequest = args.req ?? (await createLocalReq({}, payload))\n\n    await updateJob({\n      id: args.id,\n      data: {\n        completedAt: null,\n        error: {\n          cancelled: true,\n        },\n        hasError: true,\n        processing: false,\n        waitUntil: null,\n      } as {\n        completedAt: null\n        waitUntil: null\n      } & BaseJob,\n      depth: 0, // No depth, since we're not returning\n      disableTransaction: true,\n      req: newReq,\n      returning: false,\n    })\n  },\n})\n"],"names":["createLocalReq","jobAfterRead","jobsCollectionSlug","runJobs","updateJob","updateJobs","getJobsLocalAPI","payload","queue","args","undefined","workflow","config","jobs","workflows","find","slug","data","input","waitUntil","toISOString","workflowSlug","task","taskSlug","depth","runHooks","create","collection","req","doc","db","run","newReq","limit","overrideAccess","processingOrder","sequential","where","runByID","id","cancel","and","completedAt","exists","hasError","not_equals","push","equals","error","cancelled","processing","disableTransaction","returning","cancelByID"],"mappings":"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"}